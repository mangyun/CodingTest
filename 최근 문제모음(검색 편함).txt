그래도 푸니까 기분 개좋네

그리디, 완전 ,너비, 깊이 탐색
못하겠으면 일단 말로 풀어서쓰고해라
디버깅할때는 print로 먼저 봐바라

제일 중요한거~!!!!!!!!!!!!!!!!!!!!
- dfs, bfs에서 먼저 범위 벗어난 경우부터 무시하고, 그 다음 장애물일때 무시하게 코드짜라. 
이렇게안하면 index에러남!
- bfs같은 최단거리에서 시작점이 계속 더해지기때문에 visited 하는듯

그리디 - 최소, 최대 같은 문제
DFS, BFS
1. 일단 기본적으로 graph를 초기화할때, 노드가 1이 일반적이라 [ [노드 0번째 공백], [2,3,8], [1,3] ]
위와같이 0번째는 공백으로두고 지정한다.
2. 방문하기전에는, 위에서 인덱스 노드 0번째는 없으니까 visited = [False] * (n+1)
dfs 
- 재귀함수, 스택구조
bfs - from collections import deque
- 최소, 최단거리 구하기같은데 많이  사용
- 첫 방문처리 후, 꺼내고, 시작 - 덱, 큐구조

📍 DFS, BFS 모두 적합한 유형
단순히 모든 정점을 방문하는 것이 중요한 문제인 경우 어떤 것을 택해도 된다.

📍 DFS가 적합한 유형
모든 노드를, 왼쪽 위부터 오른쪽으로 하나씩 전부확인하면서 방문 안했으면 시작한다.
global 전역변수 자주 쓴다.
검색 대상 그래프가 큰 경우(정점과 간선의 개수가 많음)
경로의 특징을 저장해둬야 하는 문제
ex) 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는 데 
경로에 같은 숫자가 있으면 안된다는 문제, BFS는 경로의 특징을 가지지 못함

📍 BFS가 적합한 유형
가장 빠른, 가장 짧은 등 최단거리를 구해야 할 경우
DFS는 처음으로 발견되는 해답이 최단거리 라는 것 보장 X
반면 BFS는 현재 노드에서 가까운 곳부터 찾기 때문에 경로 탐색 시 
첫번째로 찾아지는 해답이 곧 최단거리이다.

#2차원 리스트 맵 정보 입력받기
n, m = map(int, input().split())
graph = []
for i in range(n):
  graph.append(list(map(int, input().split())))

#리스트 컴프리헨션
data = [[0]*4 for _ in range(3)]
print(data)

#입력
n = int(input())
data = list(map(int, input().split()))
 
# 입력이 매우 많다면
import sys
input = sys.stdin.readline
n, m = map(int, input().split())    
a = [list(map(int, input().split())) for _ in range(n)]

#줄바꿈 없애기
print(7, end=" ")
print(8, end=" ")

#걍 바로 문자열 편하게 출력, f 붙임
answer = 7
print(f"정답은 {answer}입니다.")

#걍 무시처리 
if score >= 80:
     pass

#함수처리
a = 10
def func():
  print(a)
func()

#람다 - 한줄에 함수 작성 쌉가능
print((lambda a, b: a+b)(3,7))

#람다 자주 사용하는 키 기준 정렬
array = [('홍길동', 50), ('이순신', 15), ('아무개', 54)]
print(sorted(array, key = lambda x: x[1]))

# 자주쓰는 라이브러리
내장 - min, sum, max, eval(계산)

itertools - 순열, 조합 모든 경우의 수 간단하게 쌉가능
1. 순열
from itertools import permutations
data = ['a', 'b', 'c']
result = list(permutations(data, 3)) # 모든 순열 구하기
print(result)
2. 중복 허용 순열
from itertools import product
data = ['a', 'b', 'c']
result = list(product(data, repeat = 2)) # 중복 허용 순열
print(result)
3. 중복 허용 조합
from itertools import combinations_with_replacement
data = ['a', 'b', 'c']
result = list(combinations_with_replacement(data, 2)) # 중복 허용 조합
print(result)

heapq - 힙, 우선순위 큐

bisect - 이진탐색

collections - 덱, 카운터
#리스트같은 내부에 원소 갯수 세주기
from collections import Counter
counter = Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])
print(counter['blue'])#원소 블루 갯수
print(dict(counter))#사전 자료형으로 변환

math - 수학



--------------------------------------------------------------------------------------------------------------

문제들 정리

백준
동전 0
for i in reversed(range(n)): - 순서 반대로 내려감

회의실  
끝나는 시간기준 먼저 정렬, 빨리 끝날수록 뒤에서 고려해볼 회의가 많기 때문이다. 
빨리 시작하는 순서대로 정렬을 우선 한다면, 오히려 늦게 끝날 수 있기 때문이다.
끝나는시간이 같은경우, 그걸 다시 시작시간 기준으로 정렬해야한다.
time.sort(key = lambda x: (x[1], x[0]))- 끝나는 시간 x[1]기준 먼저 오름차순 후, 
그 정렬값을 시작시간으로 다시 정렬, 내림차순은 -를 붙임


보물 
배열 복사는 .copy()
인덱스 받기는 .index(값)
배열 원소빼기는 .pop(인덱스) -> 인덱스 안쓰면 마지막 원소 나가리
혹은 del list(인덱스)

잃어버린 괄호
문자열 슬라이싱, 입력할때 split으로 구분하는 것
-----------------------------------------------------------------------------------------------------------

30
리스트를 문자열로 - ''.join(s)
각 자리 수의 합이 3의 배수
-----------------------------------------------------------------------------------------------------------
알파벳체크
if a.isalpha():
  ~~
-----------------------------------------------------------------------------------------------------------
셀프넘버
숫자 각 자릿수 = for j in str(n)
set - 차집합가능, 순서섞임, 자료형 중복제거 필터로 종종 사용
set은 추가할때 add,  list는 append
set내림차순은 sorted(셋, reverse=True)
-----------------------------------------------------------------------------------------------------------
한수
주접떨지말고 횟수 count나 하자
숫자 각 자릿수 떼는거 ㅈㄴ게 나온다.. 진짜.. 
-----------------------------------------------------------------------------------------------------------
ATM
리스트 값 하나씩 제외하면서 더하기 - answer += sum(P[:i])
내 답 = s += sum(m)  m.pop(-1)
-----------------------------------------------------------------------------------------------------------
바이러스 
다시해보기
DFS/BFS 풀이 중 어떤 문제는 visited 체커를 사용하는 반면 안하는 문제도 있는 것 같다.
그 차이에 대해 이해하려면 좀 더 많이 풀어봐야할 듯 하다
n = int(input())		# 컴퓨터의 수
m = int(input())		# 연결된 컴퓨터 쌍의 수

# 인접리스트 graph 선언 및 입력받기
graph = [[] for _ in range(n+1)]
for _ in range(m):							# 연결된 컴퓨터 쌍의 수만큼 반복
    x, y = map(int, input().split())		
    graph[x].append(y)
    graph[y].append(x)

visited = [0] * (n+1)	# 방문처리 : 방문한 컴퓨터 수를 출력해야하므로 visited 에 True/False가 아닌 0/1로 처리

def dfs(graph, v, visited):
    visited[v] = 1
    for i in graph[v]:
        if visited[i] == 0:
            dfs(graph, i, visited)
    return True

dfs(graph, 1, visited)
print(sum(visited)-1)	# 방문한 컴퓨터 개수 - 1번 컴퓨터


-----------------------------------------------------------------------------------------------------------


덩치
if i[0] < j[0] and i[1] < j[1]:
      rank += 1
무조건 오름차순 이딴게 아니라, 순수 앞뒤 비교만함
for i in range(n):
  a, b = map(int, input().split())
  m.append((a, b)) // map을 바로 append에 못 박음


유기농배추
- sys.setrecursionlimit(10000) 를 입력하지 않으면 런타임 오류가 발생한다.
- 파이썬의 기본 재귀 한도는 1000이고, 재귀 깊이가 1000을 넘어갈 경우 모듈을 추가해야 한다
- BFS로 풀면 런타임 오류가 발생하지 않는다고 한다
- graph의 index를 사용할 때 행과 열을 바꿔줘야 한다는 걸 잊지 말자
- graph[ny][nx]를 확인하고 -1로 변경해서 체커 역할을 한다
- x, y 위치를 지정할 때 헷갈리지 않도록 주의하도록 하자
BFS 풀이도 연습해둬야 하겠다
출력을 횟수 연속으로 할때, 답 산출은 노상관인듯?

-----------------------------------------------------------------------------------------------------------
숨바꼭질
and로 조건 주면 순차적으로 확인.
가장 짧은, 가장 빠른과 같은 것을 물어보면 BFS를 생각하자.
그리고 파이썬에서 queue는 반드시 deque를 사용해야 한다.
0은 False이고, 이외는 다 True
max = 10 ** 5 - 제곱은 **
for i in (x-1, x+1, x*2): - 이런문법 알아두자
visited = [0] * (max+1) - 인덱스는 -1되니까 +1 먼저해주자.
-----------------------------------------------------------------------------------------------------------
체스판 다시 칠하기
8X8범위만큼 가능한 모든 경우의 수를 검사하면 된다.
브루트포스 문제들이 늘 그렇듯이 조건 하나만 틀려도 와장창이니 주의할것....
체스판 색 인덱스의 합( k +j )
위와 같이, 인덱스의 합이 짝수인지 홀수인지로 체크무늬를 판단 할 수 있다.
요약
for i in range(N-7):
    for j in range(M-7):
        first_W = 0
        first_B = 0
        for k in range(i,i+8):
            for l in range(j,j + 8):
                if (k + l) % 2 == 0:
	----생략 ---
-----------------------------------------------------------------------------------------------------------
영화배우 숌
브루트 포스는 단순히 그냥 가능한 경우의 수를 전부 때려박는 알고리즘이다.
범위 지정 못할때, while 사용
나는 10*6이정도 범위로 for문을 사용했지만...
while N:
    movie += 1
    if "666" in str(movie):
        N -= 1
print(movie - 1)

연산자 끼워넣기
음수 % 양수의 몫 = int(음수 / 양수)
------------------------------------------------------------------------------------------------------------
스타트와 링크
참고
set에서의 차집합 이외로도, 아래처럼 인덱스로도 분리가능.
team1 = team[i] # team
team2 = team[-i-1] # team[i]와는 반대 원소로 이루어짐

from itertools import combinations as c # 이렇게 c 로 치환

n = int(input())
array = [i for i in range(n)]
matrix = []
for _ in range(n):
    matrix.append((list(map(int, input().split()))))
result = int(1e9)
for r1 in c(array, n//2):
    start, link = 0, 0
    r2 = list(set(array) - set(r1)) # set을 써서 차집합으로 나머지 원소 구하기
    for r in c(r1, 2):
        start += matrix[r[0]][r[1]]
        start += matrix[r[1]][r[0]]
    for r in c(r2, 2):
        link += matrix[r[0]][r[1]]
        link += matrix[r[1]][r[0]]
    result = min(result, abs(start-link))
print(result)
-----------------------------------------------------------------------------------------------------------
섬의개수
참고
대체 visited같은 체커는 언제쓰는가?

import sys
sys.setrecursionlimit(5000000)

input = sys.stdin.readline

def dfs(x,y):
  if 0 <= x < h and 0 <= y < w:# 가로 높이 구분 잘 해서 넣기
    if g[x][y] == 1:
      g[x][y] = 2
      for i in (-1 , 0 , 1): # 범위 지정 이건 잘한듯 ㅇㅇ
        for j in (-1 , 0 , 1):
          dfs(x+i, y+j)
      return True
  return False

while True:
  w, h = map(int, input().split()) # 이거 가로, 높이 구분 잘하자 제발!!

  if w == 0 and h ==0:
    break
  g = [list(map(int, input().split())) for _ in range(h)]
  
  c = 0
  
  for i in range(h): # 가로 높이 구분 잘 해서 넣기
    for j in range(w):
      if g[i][j] == 1:
        dfs(i,j)
        c += 1
             
  print(c) 
-----------------------------------------------------------------------------------------------------------
부분수열의 합
참고 
list(combinations(s, n))으로도 쉽게풀었지만,
dfs를 이용하여 재귀적으로 푼 풀이 
해당원소를 포함하는 경우/ 포함하지 않는경우로 인덱스가 늘어감에따라 가지가 뻗어나가는 형태

import sys
input = sys.stdin.readline
def dfs(idx, sum):
    global cnt
    if idx >= n: # 인덱스가 범위를 나가면 리턴
        return
    sum += s_[idx] # 현재 값을 더해주기
    if sum == s: # 원하는 값이면
        cnt += 1 # 카운트
    dfs(idx + 1, sum - s_[idx]) # 현재값을 뺀, 다음 인덱스를 시작
    dfs(idx + 1, sum) # 현재값을 그대로 더한, 다음 인덱스를 시작

n, s = map(int, input().split())
s_ = list(map(int, input().split()))
cnt = 0
dfs(0, 0)
print(cnt)
-----------------------------------------------------------------------------------------------------------
안전영역
참고 
이차원 최대,최소 구하기 = 개꿀!
graph_min = min(map(min, graph))    # min_height
graph_max = max(map(max, graph))    # max_height

import sys 
sys.setrecursionlimit(5000000) # dfs할때 무조건 박아라.
input = sys.stdin.readline

def dfs(x,y):
  if 0<= x < n and 0<= y < n:
    if z[x][y] > i and visit[x][y] == 0:
      visit[x][y] = 1
      dfs(x,y-1)
      dfs(x-1,y)
      dfs(x+1,y)
      dfs(x,y+1)
    return True  # True랑 False는 딱히 쓸거 아니면 없어도 상관은 없다.
  return False 
  
n = int(input())
z = [list(map(int, input().split())) for _ in range(n)]

k = max(map(max, z)) # 2차원 원소 최대값 -> 이거개꿀이다

count = []
for i in range(k): # (q, k) 괜히 최솟값부터 시작하려했다가 ㅈㄴ 런타임 벨류 에러남.
  c = 0
  visit = [[0] * n for _ in range(n)] # 초기화 무조건해야함
  for x in range(n):
    for y in range(n):
      if z[x][y] > i and visit[x][y] == 0:
        dfs(x,y)
        c += 1
        
  count.append(c)        
print(max(count))

-----------------------------------------------------------------------------------------------------------
날짜계산
import sys 

input = sys.stdin.readline

e = s = m = count = 1
a, b, c = map(int, input().split())

while 1:
  if e == a and s == b and c == m:
    break   
  e += 1 ;s += 1 ;m += 1;count += 1
  if e > 15 :e -= 15
  if s > 28:s -= 28
  if m > 19:m -=19
   
print(count)
-----------------------------------------------------------------------------------------------------------
나이트의 이동

import sys 
from collections import deque
input = sys.stdin.readline

t = int(input())

dx, dy = [-2,-2,-1,-1,1,1,2,2], [1,-1,2,-2,-2,2,1,-1]

def bfs(x, y):
  q = deque()
  q.append((x,y))
  
  while q:
    x, y = q.popleft()
    
    if x == a and y == b:
        return g[x][y] 
  
    for i in range(8):
      nx = x + dx[i]
      ny = y + dy[i]

      if 0<= nx < n and 0<= ny <n:
        if g[nx][ny] == 0:
          g[nx][ny] = g[x][y] + 1
          q.append((nx,ny))
          
for i in range(t):
  n =  int(input())
  x, y = map(int, input().split())
  a, b = map(int, input().split())
  g = [[0]*n for _ in range(n)]
  print(bfs(x,y))
 
-----------------------------------------------------------------------------------------------------------
로프

import sys 

input = sys.stdin.readline

n = int(input())
m = [int(input()) for _ in range(n)]

m.sort()

print(m)
for i in range(n):
  m[i] *= n-i

print(max(m))
-----------------------------------------------------------------------------------------------------------
영역구하기
참고
채우면서 count를 증가시키고 영역을 모두 채웠다면 그 count를 cnt에 저장해준다.
len(영역의 개수) = cnt의 갯수
이런 면적 찾는문제는 BFS

m, n, k = map(int, input().split())
s = [[0] * n for i in range(m)]
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
cnt = []
for i in range(k):
    x1, y1, x2, y2 = map(int, input().split())
    for j in range(y1, y2):
        for k in range(x1, x2):
            s[j][k] = 1
for i in range(m):
    for j in range(n):
        if s[i][j] == 0:
            count = 1
            s[i][j] = 1
            queue = [[i, j]]
            while queue:
                x, y = queue[0][0], queue[0][1]
                del queue[0]
                for k in range(4):
                    x1 = x + dx[k]
                    y1 = y + dy[k]
                    if 0 <= x1 < m and 0 <= y1 < n and s[x1][y1] == 0:
                        s[x1][y1] = 1
                        count += 1
                        queue.append([x1, y1])
            cnt.append(count)
print(len(cnt))
cnt.sort()
for i in cnt:
    print(i, end=' ')

-----------------------------------------------------------------------------------------------------------

프로그래머스
오픈채팅방
def solution(record):
    answer = []
    uid = {} #dic형태로 아이디번호 : 이름으로 박음
    result = []
    
    for str in record:
        t = str.split() # 공백을 기준으로 단어 쪼갬
        if t[0] == 'Enter':
            uid[t[1]] = t[2]
            result.append([t[1], '님이 들어왔습니다.'])
        elif t[0] == 'Leave':
            result.append([t[1], '님이 나갔습니다.'])
        else:
            uid.update({t[1]:t[2]}) # 업데이트 사용
            
    for i in result:
        i[0] = uid.get(i[0]) # 딕셔너리 받음
        s = ''.join(i) # 리스트를 문자열로 합치기
        answer.append(s)
            
    return answer

딕셔너리
update: 키의 값 수정, 키가 없으면 키-값 쌍 추가
popitem(), pop(키)  키-값 쌍 삭제하기
clear()모든 키-값 쌍을 삭제하기
get(키) 키의 값을 가져오기
items: 키-값 쌍을 모두 가져옴
keys: 키를 모두 가져옴
values: 값을 모두 가져옴
-----------------------------------------------------------------------------------------------------------
깔끔한 dfs 방문
sys.setrecursionlimit(5000) #재귀에러 방지
input = sys.stdin.readline

# dfs로 그래프를 탐색한다.
def dfs(start, depth):

    #해당 노드 방문체크 한다.
    visited[start] = True

    # 해당 시작점을 기준으로 계속해서 dfs로 그래프를탐색한다.
    for i in graph[start]:
        if not visited[i]:
            dfs(i, depth + 1)

깔끔한 bfs 방문
import sys
from collections import deque

input = sys.stdin.readline

def bfs(start):
    queue = deque([start])
    visited[start] = True
    while queue:
        node = queue.popleft()
        for i in graph[node]:
            if not visited[i]:
                visited[i] = True
                queue.append(i)

거리두기
이렇게 각각의 P마다 bfs를 수행하여 그 대기실의 모든 P가 거리두기를 잘 지킨다면
그 대기실에 1을 표시한다.
-----------------------------------------------------------------------------------------------------------
신고 결과 받기
코드이외참고 
from collections import defaultdict
report = set(report)
    user_list_who_i_report = defaultdict(set)
    num_of_reported = defaultdict(int)
Defaultdict는 value의 타입만 지정해준다면 key에 매핑되는 값을 하나하나 지정해주지 않아도 
자동으로 기본값이 들어가있다.

def solution(id_list, report, k):
    answer = [0] * len(id_list) 
    report = set(report) #핵심 !! 동일인물에게 한번만 신고가능해서, set으로 중복 제거
    lst = {} 
    check = {}
    
    for s in report:
        a, b = s.split(' ') # 공백을 기준으로 나눔 
        
        if b not in check: # 신고받은 내용이 아직 없다면
            check[b] = 1 # 한번 저장
        else:
            check[b] += 1 #있으면 한번 추가
            
        if a not in lst: # 누가 누굴 신고했는지 저장
            lst[a] = [b]
        else:
            if b not in lst[a]:
                lst[a] += [b] # 걍 딕셔너리 value 추가는 + 기호임
                
    for id_, n  in check.items(): # dic.items()는 키, value 전부 꺼내옴
        if n >= k: 
            for user, user2 in lst.items():
                if id_ in user2:
                    answer[id_list.index(user)] += 1 # index메소드는 list.index(값) 이런식으로 사용
    return answer
-----------------------------------------------------------------------------------------------------------
신규 아이디 추천
참고
# 문자열의 첫글자만 대문자로 변경, 문자열의 모든 단어들의 첫글자를 대문자로 변경
capitalize(), title()
ord = 문자를 숫자로, chr = 숫자를 문자로, str - 문자열로
str1 = str1.upper()
str2 = str2.upper() - 대문자로 변환
# 문자열 알파벳 모두 소문자인지 대문자인지, 서로 반전
islower(), isupper(), swapcase()
관련 함수 : string.upper(), stirng.isupper(), string.islower()
string.isalnum() - 문자열이 모두 숫자일 경우 true 리턴
string.isalpha() - 문자열이 모두 한글이나, 영어일 경우 true 리턴
isdigit() - 숫자인지

string.replace() - replace(old, new, [count]) -> replace("찾을값", "바꿀값", [바꿀횟수])
ex) text = '123,456,789,999'
replaceAll= text.replace(",","") #123456789999
replace_t2 = text.replace(",", "",2) #123456789,999
string.find("..") - ..인 문자열 찾기

def solution(new_id):
    answer = ''
    # 1
    new_id = new_id.lower() # 대문자를 소문자로
    # 2
    for c in new_id: 
        if c.isalpha() or c.isdigit() or c in ['-', '_', '.']: # isalpha(), isdigit(), in 사용
            answer += c
    # 3
    while '..' in answer: # 문장에서 ..이 나오는 부분은
        answer = answer.replace('..', '.') # answer.replace('..', '.') 앞에꺼를 뒤에꺼로 바꿈
    # 4
    if answer[0] == '.': #처음에 마침표갸 .이면
        answer = answer[1:] if len(answer) > 1 else '.' # 문자열 1개면 index 에러, 이 조건 넣어줘야함
    if answer[-1] == '.':#마지막에 마침표가 .이면
        answer = answer[:-1] # 마지막 하나자르기
    # 5
    if answer == '': # 빈문자열이면 a 넣기
        answer = 'a'
    # 6
    if len(answer) > 15:
        answer = answer[:15] # 처음부터 15개까지만 남기기
        if answer[-1] == '.': # 마침표가 끝에 위치하면, 마침표 제거
            answer = answer[:-1]
    # 7
    while len(answer) < 3: # 길이가 3보다 작으면
        answer += answer[-1] #마지막 글자 계속 추가
    return answer
-----------------------------------------------------------------------------------------------------------
숫자 문자열과 영단어
참고
 for i,c in enumerate(arr): # enumerate 로 인덱스와 값을 한번에 받을수도 있음.
        s = s.replace(c,str(i))

def solution(s):
    answer = s 
    num_s = {'zero':0, 'one':1, 'two':2, 'three':3, 'four':4, 'five':5, 'six':6, 'seven':7, 'eight':8, 'nine':9}

    for item in num_s.items():
        answer = answer.replace(item[0], str(item[1]))   

    return int(answer)
-----------------------------------------------------------------------------------------------------------
키패드 누르기
참고
키패드 좌표를 dic에다가 박고 시작하는 경우도 있었다.
 # 키패드 좌표료 변경
    dic = {1: [0, 0], 2: [0, 1], 3: [0, 2],
           4: [1, 0], 5: [1, 1], 6: [1, 2],
           7: [2, 0], 8: [2, 1], 9: [2, 2],
           '*':[3, 0], 0: [3, 1], '#': [3, 2]}
    
    # 시작 위치
    left_s = dic['*']
    right_s = dic['#']

def solution(numbers, hand):
    answer = ''
    lastL = 10
    lastR = 12
    
    for n in numbers:
        if n in [1,4,7]:
            answer+='L'
            lastL = n
        elif n in [3,6,9]:
            answer+='R'
            lastR = n
        else:
            n = 11 if n == 0 else n # 0일때 10, 12인 거리를 빼도 같아지기 위해 11 
            
            absL = abs(n-lastL)
            absR = abs(n-lastR)
            
            if sum(divmod(absL, 3)) > sum(divmod(absR, 3)): # divmod(a, b) : a를 b로 나눈 몫과 나머지를 더하는 센스
                answer+='R'
                lastR = n
            elif sum(divmod(absL, 3)) < sum(divmod(absR, 3)):
                answer +='L'
                lastL = n
            else:
                if hand == 'left':
                    answer+='L'
                    lastL = n
                else:
                    answer+='R'
                    lastR = n
                
    return answer
-----------------------------------------------------------------------------------------------------------
크레인인형뽑기
참고
문제와는 관계없는 리스트 회전 - board = list(zip(*board[::-1]))
배열 끝부분 비교를 basket[-2] == basket[-1] -> 이게 신박한 부분이었음

def solution(board, moves):
    basket = [] # 인형들을 담아줄 바구니~
    answer = 0 # 팡 터진 인형들 계산
    
    for move in moves: # 사용자의 움직임 하나씩 출력
        for column in board: # columns 출력
        	# move는 1부터 시작하기 때문에 index로 사용하기 위해선 -1씩 해줘야 함
            if column[move-1] != 0: # 만약 column의 move가 0이 아니라면 (인형이 있다는 말)
                basket.append(column[move-1]) #해당 값을 인형 바구니에 담기
                column[move-1] = 0 # 뽑은 인형은 0 처리
                
                if len(basket) > 1: # 바구니에 인형이 2개 이상 들어가는데
                    if basket[-2] == basket[-1]: # 인형이 두개가 겹친다면
                        del basket[-2] # 터뜨린다
                        del basket[-1] # 터뜨린다
                        answer += 2 # 터뜨린 인형 갯수 추가
        
                break 
    return answer 
--------------------------------------------------------------------------------------------------------------
실패율
참고
딕셔너리는 pop같은게 안된다!!
sorted(a, key = lambda x : a[x], reverse = True) 처럼 람다 꼭 기억!!

def solution(N, stages):
    a = {} # 아 그냥 선언만해도 밑에서 a[i]처럼 ㅇㅈㄹ 할 수있구나!
    for i in range(1, N+1):
        a[i] = stages.count(i) / len(stages)
        while i in stages:
            stages.remove(i)

   return sorted(a, key = lambda x: a[x], reverse= True)
--------------------------------------------------------------------------------------------------------------
1차 비밀지도
zip 써서, 두 배열 원소 동시 비교
or |, xor ^, and & 이렇게 비트연산으로 두 수 비교, 캬 클라스~
zfill써서 앞에 부족한 수만큼 0 채워주기
이진수로 바꾸면서 0b바로없애기 -> format(s, 'b')
key point: zip(), bin(i | j), rjust()(오른쪽으로 정렬해서 왼쪽부터 채움- zfill()과 유사한 기능)

def solution(n, arr1, arr2):
    answer = []

    for i, j in zip(arr1, arr2): # zip 써서, 두 배열 원소 동시 비교
        value = str(bin(i|j)[2:]) # 와 or를 쓰는건 ㄹㅇ 천재네;;
        value = value.zfill(n)# 앞에 부족한 수만큼 0 채워주기
        value = value.replace('1', '#')
        value = value.replace('0', ' ')
        answer.append(value)

    return answer

다른풀이 zip 안쓴거!
def solution(n, arr1, arr2):
    answer = []
    
    for i in range(n):
        tmp = bin(arr1[i] | arr2[i]) # or 써버리기!
        # tmp결과 ex) '0b1101'
        tmp = tmp[2:].zfill(n)
        # tmp결과 ex) '01101'
        tmp = tmp.replace('1','#').replace('0',' ')
        # tmp결과 ex) ' ## #'
        answer.append(tmp)
    
    return answer
--------------------------------------------------------------------------------------------------------------
1차 다트게임
is.digit() - 숫자 판단
제곱은 **
배열 이전원소 stack[-1]로 제발제발제발제발제발제발 이용!!

def solution(dartResult):
    stack = []
    dartResult = dartResult.replace("10", "A") #10에 대한 예외 처리해야함, 문제좀 잘봐라,..
    bonus = {'S': 1, 'D': 2, 'T': 3} #그냥 S D T 설정
    
    for i in dartResult:
        if i.isdigit() or i=='A': # 1~9거나 10이거나
            stack.append(10 if i == 'A' else int(i)) 
        elif i in ('S', 'D', 'T'): # 이런 세 조건을 볼때 제발 in 써라!
            num = stack.pop()
            stack.append(num ** bonus[i])
        elif i == '#': # 이전꺼 -1 곱하기
            stack[-1] *= -1
        elif i == '*':
            num = stack.pop()
            if len(stack):
                stack[-1] *= 2
            stack.append(2 * num)
    return sum(stack)
---------------------------------------------------------------------------------------------------------
1차 뉴스 클러스터링
floor -> import math 해야함
intersection = set(str1) & set(str2) -> 교집합
union = set(str1) | set(str2) -> 합집합

def solution(str1, str2):
    answer = 0
    str1 = str1.upper()
    str2 = str2.upper()
    list1 = []
    list2 = []
    
    for i in range(len(str1)):
        if str1[i:i+2].isalpha() and len(str1[i:i+2]) == 2:
            list1.append(str1[i:i+2])
    
    for i in range(len(str2)):
        if str2[i:i+2].isalpha() and len(str2[i:i+2]) == 2:
            list2.append(str2[i:i+2])

    c= 0
    for i in list1: //내가 풀긴했지만 신박하게 합집합, 교집합을 풀었음
        if i in list2:
            list2.remove(i)
            c += 1
    
    if len(list1) + len(list2) == 0:
        answer = 65536
    else:
        answer = int((c / (len(list1) + len(list2)) )*65536)

    return answer

다름사람 Counter를 이용한 풀이
from collections import Counter

def solution(str1, str2):
    str1_low = str1.lower()
    str2_low = str2.lower()
    
    str1_lst = []
    str2_lst = []
    
    for i in range(len(str1_low)-1):
        if str1_low[i].isalpha() and str1_low[i+1].isalpha():
            str1_lst.append(str1_low[i] + str1_low[i+1])
    for j in range(len(str2_low)-1):
        if str2_low[j].isalpha() and str2_low[j+1].isalpha():
            str2_lst.append(str2_low[j] + str2_low[j+1])
            
    Counter1 = Counter(str1_lst)
    Counter2 = Counter(str2_lst)
    
    inter = list((Counter1 & Counter2).elements())
    union = list((Counter1 | Counter2).elements())
    
    if len(union) == 0 and len(inter) == 0:
        return 65536
    else:
        return int(len(inter) / len(union) * 65536)
---------------------------------------------------------------------------------------------------------
문자열 압축
입력 문자열의 길이가 최대 1000이었으므로 완전 탐색이 가능할 것으로 생각함.
따라서 망설임 없이 loop를 두 번 타는 걸 생각했다. → O(n^2) 풀이
for문을 1, len(s) // 2 + 1까지 반복했다. 문자열 길이 범위를 꼭 축소하자
for i in range(0, n, 2) -> 여기서 2 같은 step 변수를 무조건 써야한다.

def solution(s):
    result=[]
    
    if len(s)==1:
        return 1
    
    for i in range(1, len(s)+1):
        b = ''
        cnt = 1
        tmp=s[:i]

        for j in range(i, len(s)+i, i): # 제일중요한 i만큼 바로 건너띄기!! 
            
            if tmp==s[j:i+j]:
                cnt+=1
            else:
                if cnt!=1:
                    b = b + str(cnt)+tmp
                else:
                    b = b + tmp
                    
                tmp=s[j:j+i]
                cnt = 1
                
        result.append(len(b))
        
    return min(result)
---------------------------------------------------------------------------------------------------------
튜플
참고
s.sort(key = len) -> 길이를 기준으로 오름차순
문자를 숫자로 -> int(s)
s = s.split("},{") -> 분리시키는거!!
배열 a[-2] 자릿수 찾는거 많이쓴다 진짜!!

def solution(s):
    answer = []
    s = s[2:-2] # 양 옆 괄호들 사라짐
    s = s.split("},{") # 중간 },{를 기준으로 분리
    s.sort(key = len) # 길이를 기준으로 오름차순
    
    for i in s:
        ii = i.split(',') # 다시 ,을 기준으로 분리
        
        for j in ii:
            if int(j) not in answer:
                answer.append(int(j))
    
    return answer
------------------------------------------------------------------------------------------------------------
1차 프렌즈 4블록
문제가 굉장히 길지만, 특별한 알고리즘을 요구하는 문제가 아니다.
정사각형 모양으로만 블록이 사라지므로 BFS나 DFS도 필요하지 않다.
다만, 아래 그림과 같이 정사각형이 서로 겹칠 가능성이 있다.
set 메소드 s = {'a','b','c','d','e','f'}
s.add('g') 결과: {'c', 'e', 'b', 'd', 'g', 'a', 'f'} -> 집합은 순서가 없어요!
s.remove('a') 결과: {'c', 'e', 'b', 'd', 'g', 'f'}
s.discard('b') 결과: {'c', 'e', 'd', 'g', 'f'}
print(s.pop()) 결과: c
s.clear() 결과: set()

def solution(m, n, board):
    for i in range(m):
        board[i] = list(board[i])
    
    cnt = 0
    rm = set()
    while True:
        # 보드를 순회하며 4블록이 된 곳의 좌표를 집합에 기록
        for i in range(m-1):
            for j in range(n-1):
                t = board[i][j]
                if t == []:
                    continue
                if board[i+1][j] == t and board[i][j+1] == t and board[i+1][j+1] == t:
                    rm.add((i,j));rm.add((i+1,j))
                    rm.add((i,j+1));rm.add((i+1,j+1))
        
        # 좌표가 존재한다면 집합의 길이만큼 세주고 블록을 지움 
        if rm:
            cnt += len(rm)
            for i,j in rm:
                board[i][j] = []
            rm = set()
        # 없다면 함수 종료
        else:
            return cnt
        
        # 블록을 위에서 아래로 당겨줌
        while True:
            moved = 0
            for i in range(m-1):
                for j in range(n):
                    if board[i][j] and board[i+1][j]==[]:
                        board[i+1][j] = board[i][j]
                        board[i][j] = []
                        moved = 1
            if moved == 0:
                break

------------------------------------------------------------------------------------------------------------
트리의 부모찾기
기본적으로 반복은 1000회
sys.setrecursionlimit(500000) -> 이거 무조건 해줘야함

import sys 
sys.setrecursionlimit(500000) # 개중요함!!
input = sys.stdin.readline

n = int(input())
g = [[] for _ in range(n+1)]

for _ in range(n-1):
  a, b = map(int, input().split())
  g[a].append(b)
  g[b].append(a)

visited = [0]*(n+1)
visited[1] = 1
node = [0]*(n+1)

def dfs(start):  
  for i in g[start]:
    if visited[i] == 0:
      visited[i] = 1
      dfs(i)
    else:
      node[start] = i
    
dfs(1)

for i in range(2, n+1):
  print(node[i])
-----------------------------------------------------------------------------------------------------------
촌수 계산
그냥 전형적인 bfs, dfs 문제
시작촌수, 목표촌수 

from collections import deque
import sys
input = sys.stdin.readline
n = int(input())
a, b = map(int, input().split())
m = int(input())
adj = [[] for i in range(n + 1)]
result = [0 for i in range(n + 1)]
def bfs(start):
    q = deque()
    q.append(start)
    visit = [0 for i in range(n + 1)]
    visit[start] = 1
    while q:
        d = q.popleft()
        for i in adj[d]:
            if visit[i] == 0:
                visit[i] = 1
                result[i] = result[d] + 1 # 현재촌수 +1 값을 이동할 촌수값에 넣기
                q.append(i)
for i in range(m):
    x, y = map(int, input().split())
    adj[x].append(y)
    adj[y].append(x)
bfs(a)# 시작 촌수는 a
print(result[b] if result[b] != 0 else -1) # b가 a와 촌수가 없으면 -1
-----------------------------------------------------------------------------------------------------------\
주유소
참고
그림을 그려 차분히 로직을 생각하고 구현하는 습관을 길러야겠다.
그리디 같은 문제는 생각보다 많은 스킬이 필요하지 않을수도있다.
min값을 먼저 일단 지정하고 비교해서 바꿔줌

import sys
input = sys.stdin.readline

N = int(input())

roads = list(map(int,input().split()))
costs = list(map(int,input().split()))

# 첫번째 값 더하기
min_price = roads[0] * costs[0]

# 가장 값이 싼 주유소 지정
min_cost = costs[0]

for i in range(1, N-1): # 여기부터가 진짜중요
  if min_cost > costs[i]: # 가장 값이 싼 주유소가 현재 주유소 보다 비싸면 바꿔준다.
    min_cost = costs[i] # 값 싼 주유소로 바꿔주기
  
  min_price += min_cost * roads[i]

print(min_price)
-----------------------------------------------------------------------------------------------------------
수들의합
갯수가 최대가 되려면, 값을 넘기직전까지 1부터 더해주다가, 나머지 한개의 수로 채워주면된다.
각 sum과 count를 따로 선언해주거나, 합의공식을 이용함

s = int(input())
n = 1
while n * (n + 1) / 2 <= s:
    n += 1
print(n - 1)
-----------------------------------------------------------------------------------------------------------
30
30의 배수는 -> 3의 배수로 보고 시작한다!!
30의 배수의 조건
1. 전체 각 자리의 합이 3의배수
2. 끝이 0으로 끝나야함 

n = input()
n = sorted(n, reverse=True)
sum = 0
if '0' not in n:	# 우선은 input의 디폴트인 string으로 받았기에 '0' 문자로 적음
    print(-1)
else:
    for i in n:
        sum += int(i)
    if sum % 3 != 0 :	# 3의 배수 체크하면, 0만 붙였을때 30의 배수이다.
        print(-1)
    else :
        print(''.join(n))
-----------------------------------------------------------------------------------------------------------
모든순열
모든 순열을 탐색해서 출력하면 된다.
dfs를 통해 백트래킹을 했고 출력을 했다.
순열을 구하기 위해 위의 테크닉을 잘 알고 있으면 좋을 것 같다.

import sys
input = sys.stdin.readline
n = int(input())
temp = []

def dfs():
    if len(temp) == n: # 전체 길이가 같다면 출력
        print(temp)
        return
    for i in range(1, n + 1): 
        if i not in temp: # 1부터 하나씩
            temp.append(i) # 1추가
            dfs() # 더 깊게 들어가기, 1 제외 2 먼저 넣기, 그다음 3 넣기
            temp.pop() # 3, 2 순서로 빼고, 다시 반복문으로 가서, 이번엔 3부터 넣기

dfs()
-----------------------------------------------------------------------------------------------------------
신입사원
키 정렬할때, 그냥 sort로 하면 앞 인덱스 기준으로 정렬됨
이런 min, max 를 for문 비교과정에서 바꿀줄 아는 스킬을 길러야함.
-> 계산량을 줄이기위해!

import sys
input = sys.stdin.readline

T = int(input()) #테스트케이스

for i in range(0,T):
    Cnt = 1
    people = []
    
    N = int(input())
    for i in range(N):
        Paper, Interview = map(int,sys.stdin.readline().split())
        people.append([Paper, Interview])

    people.sort() # 서류 기준 오름차순 정렬
    Max = people[0][1] #서류는 기준으로 정렬했으므로, 면접순위 대입
    
    for i in range(1,N):
        if Max > people[i][1]: #이후사람이 면접순위가 더 높으면 
            Cnt += 1 # 채용
            Max = people[i][1] # 순위 교체

    print(Cnt)
-----------------------------------------------------------------------------------------------------------
gcd합
import math해서 math.gcd 할수도있지만, 함수로 구하는것도 알아둬라.
아래 코드는 골때리는코드, 같은 비교군에서 원소비교할때 개좋을듯?
for i in range(k):
        for j in range(k):
            if i<j : # 진행하지 않은 나머지 원소

import sys
input = sys.stdin.readline

n = int(input())

def gcd(a, b) : # 최대공약수 구하기, 아니면 import math 쓰셈 -> math.gcd
    if b==0:
        return a
    else :
        return gcd(b,a%b)

for _ in range(n):
    arr = list(map(int,input().split()))
    k = arr.pop(0) # 처음 개수는 빼버림
    sum = 0
    for i in range(k):
        for j in range(k):
            if i<j : # 진행하지 않은 나머지 원소
                sum += gcd(arr[i],arr[j])
    print(sum)

-----------------------------------------------------------------------------------------------------------
외판원 순회 2
참고
출발도시를 어디로 정하든 무조건 사이클이 발생해서 상관없기때문에, 출발지를 정하자!
res = sys.maxsize # 일단 최소비교를 위해, 처음엔 최대치로 박아놓음.
if add > res: # 일단 첫번째 루트값이 담겨있는데 두번째 루트진행시, 전체 비용도 계산안했는데, 중간 비용이 이미 최소비용보다 커버린다면 종료
      return
if sum(visited) == n-1: # 첫번째는 방문체크 안했으므로, 나머지 도시 다 방문했을때
    if g[f][0] != 0: # 값이 있다면
      res = min(res, add+g[f][0]) # 현재 res와, 마지막도시에서 첫번째로 이동할때값을 더한것과 비교
      return

import sys
input = sys.stdin.readline

n = int(input())

g = [list(map( int, input().split())) for _ in range(n)]

visited = [0] *n
res = sys.maxsize # 일단 최소비교를 위해, 처음엔 최대치로 박아놓음.

def dfs(f, add, visited):
  global res

  if add > res: # 일단 첫번째 루트값이 담겨있는데 두번째 루트진행시, 전체 비용도 계산안했는데, 중간 비용이 이미 최소비용보다 커버린다면 종료
      return
  
  if sum(visited) == n-1: # 첫번째는 방문체크 안했으므로, 나머지 도시 다 방문했을때
    if g[f][0] != 0: # 값이 있다면
      res = min(res, add+g[f][0]) # 현재 res와, 마지막도시에서 첫번째로 이동할때값을 더한것과 비교
      return

  for i in range(1, n): 
    if g[f][i] != 0 and visited[i] ==0: # 값이 있고, 아직 방문안했으면
      visited[i] = 1 
      dfs(i, add+g[f][i], visited) # 비용 더해서, 다음 도시 탐색
      visited[i] = 0
  
for i in range(1, n): # 출발지를 어디를 해도 상관이없다.
  if g[0][i] != 0: # 그래서 첫번째 도시부터 출발
    visited[i] = 1 #출발도시는 range(1, n)에서 걸러져서, 방문체크일단 안함
    dfs(i, g[0][i], visited)
    visited[i] = 0 # 방문했으면 다시 해제
  
print(res)
-----------------------------------------------------------------------------------------------------------
뒤집기
탐욕 알고리즘 -> 단순하게 시작 
길이에 관계없이 문자가 바뀌는지만 봄 -> 0001100은 010으로 봐도 무방
다음은 길이에 따라 최소 몇번 바꿔야하는지를 적은것이다.

S = input()
count = 0
for i in range(len(S)-1):
    if S[i] != S[i+1]:
        count += 1
print((count + 1) // 2)

내풀이 -> 정석이 너무 간단해서 쌉현타!
import sys
input = sys.stdin.readline

s = input()
s= s.replace(s[-1], '')

if s.split('0') > s.split('1'):
  s = s.split('1')
else:
  s = s.split('0')

a = []
for i in s:
  if i != '':
    a.append(i)

print(len(a))
-----------------------------------------------------------------------------------------------------------
A->B
참고
q.append((a,1)) # c를 같이 넣어서 횟수를 따로세줌.
 if s > b: # 크면 그 큐는 종료
    continue

import sys
input = sys.stdin.readline

a, b = map(int, input().split())

from collections import deque

q= deque()
q.append((a,1)) # c를 같이 넣어서 횟수를 따로세줌.

while q: 
  s, c = q.popleft()

  if s > b: # 크면 그 큐는 종료
    continue

  if s == b:
    print(c)
    break
    
  if s*10 +1 <= b:
    q.append((s*10 +1, c+1))
  if s*2 <= b:
    q.append((s*2, c+1))
else: # while 문에 else를 붙혀서, q가 비었다면 이라고 할수있다.
  print(-1)
-----------------------------------------------------------------------------------------------------------
문자열

import sys
input = sys.stdin.readline

a, b = input().split()

def com(a, b):
  global c
  for i in range(len(a)):
    if a[i] != b[i]:
      c+=1

c = 0
l = []

for i in range(len(b) -len(a) + 1):
  com(a, b[i:len(a)+i])
  l.append(c)
  c= 0

print(min(l))
-----------------------------------------------------------------------------------------------------------
사탕게임
그 이유는 테이블 크기가 50보다 작기 때문에 -> 완전탐색 
이문제는 브루트포스의 정석과 같은 문제이다. 
단 한번이라도 조건이 틀리면 오답이 나오니 유의해야한다.
특히 사탕색을 바꾸고 개수를 계산한다음, 다시 색을 원 상태로 돌려 놓아야 한다는 점

n = int(input())
candies=[]
ans = 1
 
for i in range(n):
    temp =[]
    temp_str = input()
    for j in range(n):
        temp.append(temp_str[j])
    candies.append(temp)
    

    
# 몇개 먹을 수 있는지 찾는 함수
def search():
    global ans
    for i in range(n):
        cnt = 1
        for j in range(n-1):
            if candies[i][j]== candies[i][j+1]:
                cnt+=1
                ans = max(cnt,ans)
            else:
                cnt = 1
        #ans = max(cnt,ans)
        
    for i in range(n):
        cnt = 1
        for j in range(n-1):
            if candies[j][i] == candies[j+1][i]:
                cnt+=1
                ans = max(cnt,ans)
            else:
                cnt = 1
        #ans = max(cnt,ans)

        


# [모든 인접한 두 자리 뒤집어보고 찾기]    
# 가로 뒤집기
for i in range(n):
    for j in range(n-1):
        candies[i][j],candies[i][j+1] = candies[i][j+1],candies[i][j]
        search()
        candies[i][j],candies[i][j+1] = candies[i][j+1],candies[i][j]

# 세로 뒤집기
for i in range(n):
    for j in range(n-1):
        candies[j][i],candies[j+1][i] = candies[j+1][i],candies[j][i]
        search()
        candies[j][i],candies[j+1][i] = candies[j+1][i],candies[j][i]

        
print(ans)
-----------------------------------------------------------------------------------------------------------
캠핑

import sys

input = sys.stdin.readline

t= 1
while 1:
  l, p, v = map(int, input().split())

  if l==0 and p ==0 and v ==0:
    break
  
  if  l > v % p:
    c = (v // p) * l + v % p
  else:
    c = (v // p) * l + l
    
  print('Case ' +str(t) +': '+ str(c))
  t+=1
-----------------------------------------------------------------------------------------------------------
부등호
백트래킹 강의라도 봐라 이 시발앝ㄹ타
처음 만들어진 문자열이 최솟값, 마지막에 만들어진 문자열 최댓값.
  
import sys

input = sys.stdin.readline

n = int(input())
a = list(input().split())
visited = [False] * 10

max = ''
min = ''

def possible(i,j,k):
  if k=='<':
    return i<j
  else:
    return i>j

def solve(cnt,s):
  global max, min
  if cnt == n+1: # 길이가 같다면, 추가
    if not len(min): # 최솟값이 없다면 최솟값으로 추가
      min = s
    else:# 있다면 최대값으로 추가
      max = s

  for i in range(10):
    if not visited[i]: #특정 숫자를 아직 방문안하면,
      if cnt ==0 or possible(s[-1], str(i), a[cnt-1]):
        visited[i]= True # 방문하고 
        solve(cnt+1, s+str(i))
        visited[i] = False# 방문 안함
  

solve(0,'')
print(max)
print(min)
-----------------------------------------------------------------------------------------------------------
기타줄
람다 정렬 기억하기!!
아니면 애초에 입력할떄 바로, 정렬시킬수 있다.
  
import sys

input = sys.stdin.readline

n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(m)]

list1 = sorted(a, key=lambda x: x[0])# 0열로 따로 정렬
list2 = sorted(a, key=lambda x: x[1]) # 1열로 따로정렬

s = 0

while 1:
  if n > 6:
    if list1[0][0] < list2[0][1] * 6:
      s += list1[0][0]
      n-=6
    else:
      s += list2[0][1] * 6
      n-=6
  else:
    if list1[0][0] < list2[0][1]*n:
      s += list1[0][0]
      
    else:
      s += list2[0][1] * n
  
    break
    
print(s)
-----------------------------------------------------------------------------------------------------------
맥주마시면서 걸어가기
처음 집과, 페스티벌을 따로 지정해줘도 되고,
한번에 선언했을때, 집인 0에서 출발하고, 마지막은 페스티벌에서 도착한다.

import sys
from collections import deque
input = sys.stdin.readline

def bfs():
    q = deque()
    q.append([home[0], home[1]]) # 처음 집에서 시작
    while q:
        x, y = q.popleft()
        if abs(x - fest[0]) + abs(y - fest[1]) <= 1000: # 축제까지 거리가 1000이하면 happy
            print("happy")
            return
        for i in range(n):
            if not visited[i]: # 아직 방문하지않았다면
                new_x, new_y = conv[i] # 편의점 좌표넣기
                if abs(x - new_x) + abs(y - new_y) <= 1000:
                    q.append([new_x, new_y]) # 점점 축제와 가까워짐
                    visited[i] = 1
    print("sad") # 1000이하가 아니라면 , sac
    return

t = int(input())
for i in range(t):
    n = int(input())
    home = [int(x) for x in input().split()] # 
    conv = []
    for j in range(n):
        x, y = map(int, input().split())
        conv.append([x, y])
    fest = [int(x) for x in input().split()]
    visited = [0 for i in range(n+1)] #home 제외
    bfs()
  -----------------------------------------------------------------------------------------------------------
효율적인 해킹
신뢰하는 관계 => 일방향 간선으로 생각해서 그래프 탐색.
너비우선(BFS)으로 탐색하면서 방문한 정점의 수를 기록.
최대치를 찾아야 하므로 모든 경우를 탐색.
단, Python3 가 아닌 PyPy3로 제출해야 한다.

import sys
input = sys.stdin.readline # 중요!!!!, 입력 속도가 느리면 통과 불가능.
from collections import deque

# 너비 우선 탐색
def bfs(s):
    D = 0
    q = deque()
    q.append(s)
    visit = [0] * (N + 1)
    visit[s] = 1
    while q:
        here = q.popleft()
        D += 1
        for w in G[here]:
            if not visit[w]:
                visit[w] = 1
                q.append(w)
    return D # 방문한 정점의 수 D를 리턴한다.
                
N, M = map(int, input().split())
G = [[] for _ in range(N+1)]
for i in range(M):
    a, b = map(int, input().split())
    G[b].append(a)
mxd = 0
result = []
for i in range(1, N + 1):
    if G[i]:
        tmp = bfs(i) # 리턴값을 받아서 최대값과 비교
        if mxd <= tmp:
            if mxd < tmp:
                result = []
            mxd = tmp
            result.append(i)
print(*result) 
  -----------------------------------------------------------------------------------------------------------  
행렬 
입력할때 걍 개쓰레기같은ㅇ 문제
2차원 배열의 맨 왼쪽 위씩만 비교
  
import sys

input = sys.stdin.readline

count = 0
N,M = map(int,input().split())

change_maps = [list(map(int ,input().strip())) for _ in range(N)] # strip해서 enter 공백 제거해야함
result_maps = [list(map(int ,input().strip())) for _ in range(N)] 

def convert3x3(x,y,arr): # 행렬에서 3*3부분만 바꾸기
    for i in range(x,x+3):
        for j in range(y,y+3):
            change_maps[i][j] = 1 - change_maps[i][j] # 0, 1 스왑

for i in range(0,N-2): # 행렬 맨 왼쪽위만 비교
    for j in range(0,M-2):
        if change_maps[i][j] != result_maps[i][j]: # 배열의 값이 같지 않다
            convert3x3(i,j,change_maps)
            count += 1

# 전체 배열 검사
nonReulst = False
for i in range(0,N):
    for j in range(0,M):
        if change_maps[i][j] != result_maps[i][j]:
            nonReulst = True

if(nonReulst):
    print(-1)
else:
    print(count)  
  -----------------------------------------------------------------------------------------------------------
마인크래프트
고수들 마인드 -> 문제 조건으로 어떻게 풀지 생각함!!!
높이를 0부터 256 하나하나 다해봄.
왜냐면, 256 * 500 * 500 해도 1억이 안넘으니, 충분히 1초 안에 완전탐색으로 풀수있음
단, PyPy3 로 제출해야 정답이 인정된다.
min, max를 따로따로 갯수를 계산해서, 채울수 있다면 마지막에 한번에 시간 계산

from math import inf
import sys

N, M, B = map(int, input().split())
ground = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

tall = 0
ans = inf # 시간초과 방지를 위해 충분히 큰 수로 둠

for i in range(257): # 땅의 높이의 최대는 256이므로 0 ~ 256까지만 탐색
    max = 0
    min = 0
    for j in range(N): # 가로
        for k in range(M): # 세로
            if ground[j][k] < i: # 블럭이 현재 높이 보다 작다면
                min += (i - ground[j][k]) # 현재 높이가 블록 높이보다 높을 때 (min 만큼 인벤토리에서 꺼내서 채워야 함)

            else:
                max += (ground[j][k] - i) # 블록 높이가 현재 높이보다 높을 때 (max 만큼 블록이 제거된 후 인벤토리에 들어감)

    inventory = max + B # 인벤토리에 있는 총 블록수 = 현재 인벤토리에 있는 블록 + max

    if inventory < min: # 전부 채울 수 없으므로 패스
        continue

    # 한번에 제거와, 추가 시간 계산
    time = 2 * max + min # 블록 제거는 2초, 블록 추가는 1초

    # 시간을 진행될수록 최소로 갱신
    if time <= ans: # 높이는 0 ~ 256 까지 오름차순으로 탐색하기 때문에 걸린 시간이 같아도 더 높은 높이가 출력 된다
        ans = time
        tall = i

print(ans, tall) 
  -----------------------------------------------------------------------------------------------------------
문서검색
진짜 ㅈ같은게 input은 \n까지 입력된다. 그래서 삭제해줘야됨.
find는 찾은 문자의 가장 첫번째 인덱스를 알려줌.
count는 이미 체크한 단어는 제외하고 계산함.
ex) ababababa
count(aba) # 2

내 풀이 1. 걍 count 쓰기 - ㅅㅂ 현타옴
import sys

input = sys.stdin.readline

s = input()
s = s[:-1]
r = input()
r = r[:-1]

print(s.count(r)) 

내 풀이 2. 걍 find쓰기
import sys

input = sys.stdin.readline

s = input()
r = input()
r = r[:-1]

c= 0

while 1 :

  if r not in s:
    break
    
  s= s[s.find(r)+len(r):] # find는 찾은 문자의 가장 첫번째 인덱스를 알려줌.
  c += 1

print(c)

다른풀이 3. replace로 단어를 바꿔서 찾아버린다.
import collections
N = input()
M = input()
N=N.replace(M,'@')
#print(N)
a=dict(collections.Counter(list(N)))
if '@' in a:
    print(a['@'])
else:
    print(0)
  -----------------------------------------------------------------------------------------------------------
수리공 항승
예시를 먼저 생각하고, 그림그리면서 해보자!
이 방법은 앞 뒤 간격을 계산할 필요가 없기 때문에 구현하는 데에 있어서 훨씬 간단하다.

import sys

input = sys.stdin.readline

N,L = map(int, input().split())

location = list(map(int,input().split()))
location.sort() # 오름차순은 해줘야함.

start = 0
cnt=0
for loc in location:
    if start<loc:
        #테이프 붙이기
        # start+L-1 까지는 자동으로 수리됨.
        start = loc+L-1
        cnt+=1

print(cnt)
  ----------------------------------------------------------------------------------------------------------
정사각형
n과 m의 작은값으로 시작함
완전탐색이라, 너무 깊게 생각하지말고 그냥 단순하게 전부 하는것도 방법이다.

import sys

input = sys.stdin.readline

n, m = map(int, input().split())

g = [list(map(int ,input().strip())) for _ in range(n)]

k = n if n <= m else m

li = []
for s in reversed(range(k)):
  if len(li) == 1:
      break
  for i in range(n-s):
    if len(li) == 1:
      break
    for j in range(m-s):
      if g[i][j] == g[i][j+s] == g[i+s][j] == g[i+s][j+s]:
        li.append((s+1)**2)
        break
        
print(li)  
  ----------------------------------------------------------------------------------------------------------
그림
bfs할때 맨 처음
1, 1
0 
조건일때 예외 처리를 해줘야한다!

import sys
from collections import deque
input = sys.stdin.readline

n, m = map(int, input().split())

g = [list(map(int ,input().split())) for _ in range(n)]

dx, dy = [-1,1,0,0],[0,0,-1,1]

def bfs(i,j):
  q= deque()
  q.append((i,j))
  
  global c

  while q:
    x, y = q.popleft()

    for i in range(4):
      nx = x + dx[i]
      ny = y + dy[i]

      if 0<= nx < n and 0<= ny < m:
        if g[nx][ny] == 1:
          g[nx][ny] = 0
          c+=1
          q.append((nx,ny))

li = []
for i in range(n):
  for j in range(m):
    if g[i][j] == 1:
      g[i][j] = 0
      c= 1
      bfs(i,j)
      li.append(c)
    else:
      continue

if len(li) == 0:
  print(0)
  print(0)
else:
  print(len(li))
  print(max(li))
  ----------------------------------------------------------------------------------------------------------
숫자야구
한번에 입력을 받는게 아니라, 받을때마다 비교한다.
값을 삭제할때마다, 인덱스를 앞으로 당겨줘야한다.

from itertools import permutations
num = list(permutations((1, 2, 3, 4, 5, 6, 7, 8, 9), 3))  # 서로 다른 수의 세 자리 숫자

t = int(input())
for _ in range(t):
    q, strk, ball = map(int, input().split())
    removed = 0  # 중간의 리스트 길이를 변경하기 때문에 필요한 변수
    q = list(str(q))

    for i in range(len(num)):
        sCnt, bCnt = 0, 0
        i -= removed # 일단 맨처음엔 인덱스가 바뀌지않았다. 다음부터 삭제한 만큼 앞으로 당긴다.
        for j in range(3):
            q[j] = int(q[j])
            if q[j] in num[i]:  # 질문한 숫자의 j번 인덱스의 숫자가 num의 i번째 튜플에 있는가
                if j == num[i].index(q[j]):  # 있고, 위치도 같으면 스트라이크 횟수 ++
                    sCnt += 1
                else:  # 위치는 다르지만 있다면 볼 횟수 ++
                    bCnt += 1
        if sCnt != strk or bCnt != ball:  # 질문을 통해 얻은 답변과, 순열을 통해 얻은 스트라이크, 볼 횟수가 다르면
            num.remove(num[i])  # 후보지에서 제외
            removed += 1  # 달라진 리스트 길이를 위해 removed --
print(len(num)) # 다 지우고 남은 선택지 갯수
  ----------------------------------------------------------------------------------------------------------
특정 거리의 도시찾기
bfs는 모든 노드의 거리가 동일할떄 사용
아 bfs 시발 좀만 더 단순하게 생각하고, 첫 번쨰 도시일때 무조건 예외 체크!!!! 시밞 명윤아ㅏ
import sys
from collections import deque

input = sys.stdin.readline

# N 도시 수, M 도로 수, K 거리 정보 X 출발 도시
N, M, K, X = map(int, input().split(' '))
graph = [[] for _ in range(N+1)]

for _ in range(M):
  a, b =  map(int, input().split(' '))  
  graph[a].append(b)

distance = [0] *(N+1)
distance[X] = 0

# BFS 부분
q = deque([X])
while q:
  now = q.popleft()

  for next in graph[now]:
    if distance[next] == 0:
      distance[next] = distance[now]+1
      q.append(next)

# K값이 distance에 있다면 i값출력 없다면 -1 출력
if K in distance:
  for i in range(1, N+1):
    if distance[i] == K:
      if i == 1:
        print(-1)
      else:
        print(i)
else:
  print(-1)


내 풀이 반례좀 알려줘라 제발
import sys
from collections import deque

input = sys.stdin.readline

n, m, k, x = map(int, input().split())

li = []

def bfs(start):
  q = deque()
  q.append(start)

  while q:
    s = q.popleft()

    for i in g[s]:

      if visited[i]:
        continue
        
      visited[i] = visited[s] +1

      if visited[i] != k:
         q.append(i)
      else:
          li.append(i)
          continue

  if len(li) ==0 or start in li:
      print(-1)
  else: 
    for i in li:
      print(i)

g = [[] for _ in range(n+1)]

visited = [0] * (n+1)

for i in range(m):
  a, b = map(int, input().split())
  g[a].append(b)

bfs(x)
  ----------------------------------------------------------------------------------------------------------
점프점프
dp = [-1] * n # 가장 마지막에 없을 경우는 -1 출력위해서
dp[start] = 0 # 처음시작하는 부분만 0으로 시작해서 거리 측정
최소문제이므로, dfs로 하면 시간초과
탐색이 의외로 단순하게 풀린다!! 

import sys
sys.setrecursionlimit(1000000)

input = sys.stdin.readline

n = int(input())
lst = list(map(int, input().split()))

dp = [-1] * n # 가장 마지막에 없을 경우는 -1 출력위해서

def bfs(start):
    q = []
    q.append(start)
    dp[start] = 0 # 처음시작하는 부분만 0으로 시작해서 거리 측정
    while q:
        now = q.popleft()
        jump = lst[now]
        for i in range(jump, 0, -1): # 큰 범위부터 점프
            if now + i < n and dp[now + i] == -1: # 마지막 지점까지의 범위고, 아직 방문하지안했으면,
                dp[now + i] = dp[now] + 1 # 이전에 온 거리만큼 1 점프
                q.append(now + i) # 큐에 넣기

bfs(0)
print(dp[-1]) # 마지막 지점의 거리 출력. 없으면 그대로 -1 임

다른풀이 dp
import sys

n = int(sys.stdin.readline())
a = list(map(int, sys.stdin.readline().split()))
dp = [sys.maxsize] * (n + 1)
dp[0] = 0

# 반복문을 통해 점프를 확인한다.
for i in range(n):
    # 점프로 갈 수 있는 칸을 확인
    for j in range(a[i]):
        if i + j + 1 < len(dp):
            # 점프한 칸에 점프 횟수에 값을 최솟값으로 초기화
            dp[i + j + 1] = min(dp[i + j + 1], dp[i] + 1)

# 마지막 칸에 점프 횟수로 바꼈다면 점프 횟수를 출력
if dp[n - 1] < sys.maxsize:
    print(dp[n - 1])
else:
    print(-1)
----------------------------------------------------------------------------------------------------------
병든 나이트
조건이 시발 무슨 20억이상인 자연수여;;
그럼 bfs는 아니고 dfs도 아니고 그리디임.
----------------------------------------------------------------------------------------------------------
음식물 피하기 
기본적인 dfs, bfs 문제
방문해준건 0으로 해주는게 중요!
---------------------------------------------------------------------------------------------------------
팰린드롬 만들기
비슷하게 생각했엇는데 아쉽..
앞만 만들어놓고, 리버스 시켜 뒤에 덧붙혀준다고 생각하자!

 = list(input())
alphabet = [chr(i) for i in range(65, 91)]
alphabet_cnt = [0 for i in range(len(alphabet))]

odd_cnt = 0
odd_chr = ""
for i in range(len(alphabet)):
    alphabet_cnt[i] = s.count(alphabet[i])
    if alphabet_cnt[i] % 2 == 1:
        odd_cnt += 1
        odd_chr = alphabet[i]

s = sorted(list(set(s)))
ans_front = []
for j in s:
    if odd_cnt >= 2:
        print("I'm Sorry Hansoo")
        quit()
    ans_front.append(j*(alphabet_cnt[alphabet.index(j)] // 2))

ans_back = list(reversed(ans_front))

if odd_cnt == 1:
    ans_front.append(odd_chr)
ans = ans_front + ans_back

print(*ans, sep="")
---------------------------------------------------------------------------------------------------------
연속부분 최대곱
전형적인 현재와, 이전에 계산한 값을 비교하는 DP문제
각 값을 기존 배열에 넣고, 최대값을 산출
print('{:.3f}'.format(max(f)))# 소수점 셋째까지 반올림해서 나옴.

import sys

input = sys.stdin.readline

n = int(input())
f = [float(input()) for _ in range(n)]


for i in range(1, n):
  f[i] = max(f[i]*f[i-1], f[i])

print('{:.3f}'.format(max(f)))
---------------------------------------------------------------------------------------------------------
카드합체 놀이
반면 우선순위 큐를 사용하면, 값이 바뀐 카드 2개를 다시 우선순위 큐 자료구조 안에 삽입하기만 하면 된다. 
heap에서 삽입 연산의 시간 복잡도는 O(logn)으로, 훨씬 효율적이다.

내풀이
import sys

input = sys.stdin.readline

n, m = map(int, input().split())

l = list(map(int, input().split()))

for i in range(m):
  l = sorted(l)
  k = l[0] +l[1]
  l[0] = k
  l[1] = k

print(sum(l))

힙 이용
from sys import stdin
import heapq

n, m = map(int, stdin.readline().split())

cards = [int(x) for x in stdin.readline().split()]
# cards 리스트를 heap으로 변환
heapq.heapify(cards)

for _ in range(m):
    card1 = heapq.heappop(cards)
    card2 = heapq.heappop(cards)

    heapq.heappush(cards, card1 + card2)
    heapq.heappush(cards, card1 + card2)

print(sum(cards))
---------------------------------------------------------------------------------------------------------
친구
그냥 ㅈㄹ 하지말고 bfs로 풀자 
플로이드 워셜
for문 중첩 3번에
if 같은경우 continue
if [i][j] == 'Y' or ([i][k] == 'Y' and [k][j] == 'Y' )

import sys
from collections import deque

# bfs 탐색
def bfs(v):
    visited = [False] * n
    queue = deque([[v, 0]]) # 사람의 번호와 친구와의 관계
    visited[v] = True
    cnt = 0
    while queue:

        a, b = queue.popleft()

        # 친구와의 관계가 2이상이면 생각하지 않는다.
        if b >= 2:
            continue

        # 반복문을 통해 탐색하지 않은 사람이고 그 사람이 친구가 있는지 확인
        for i in range(n):
            if not visited[i] and graph[a][i] == "Y":
                cnt += 1
                visited[i] = True
                queue.append([i, b + 1])

    return cnt

n = int(sys.stdin.readline())
graph = [list(map(str, sys.stdin.readline().strip())) for _ in range(n)]

res = 0
# 각 사람마다 친구의 2-친구의 수를 구하고 제일 유명한 사람을 출력한다.
for i in range(n):
    res = max(res, bfs(i))

print(res)
---------------------------------------------------------------------------------------------------------
모의고사
하 ㅅㅂ 명윤아 한번에 다 하려고 개ㅈㄹ하지말고 그냥 순서대로 변수 하나씩 짜라..
완전탐색같은거 제발 차근차근해라.. 하 개 ㅅㅂ
규칙발견.

----------------------------------------------------------------------------------------------------
소수찾기
참고
per += list(permutations(nums, i))        # 이게 그냥 []배열에 이어서 추가되는거임!!

어떤 수의 약수는 항상 짝이 존재한다. 
짝을 이루는 두 수가 다른 수라면 하나는 크고 하나는 작을 것이다. (당연한 말)
약수의 짝 중 작은 수는 제곱근보다 크지 않을 것이다. 
그렇기 때문에 range 의 끝 범위를 total ** 0.5 까지 하면 된다.


from itertools import permutations

def solution(numbers):
    answer = []                                   
    nums = [n for n in numbers]                   # numbers를 하나씩 자른 것
    per = []                                      
    for i in range(1, len(numbers)+1):            # numbers의 각 숫자들을 순열로 모든 경우 만들기
        per += list(permutations(nums, i))        # 이게 그냥 []배열에 이어서 추가되는거임!!
    new_nums = [int(("").join(p)) for p in per]   # 각 순열조합을 하나의 int형 숫자로 변환

    for n in new_nums:                            # 모든 int형 숫자에 대해 소수인지 판별
        if n < 2:                                 # 2보다 작은 1,0의 경우 소수 아님
            continue
        check = True            
        for i in range(2,int(n**0.5) + 1):        # n의 제곱근 보다 작은 숫자까지만 나눗셈
            if n % i == 0:                        # 하나라도 나눠떨어진다면 소수 아님!
                check = False
                break
        if check:
            answer.append(n)                      # 소수일경우 answer 배열에 추가

    return len(set(answer))                       # set을 통해 중복 제거 후 반환
-----------------------------------------------------------------------------------------------------
카펫
당연하게 적으면 됐을것을... ㅅㅂ
수학 수식도 이용한다. 입출력 예를 자세히보고 규칙을 파악하자.

def solution(brown, yellow):
    answer = []
    total = brown + yellow                  # a * b = total
    for b in range(1,total+1):
        if total % b == 0:            # total / b = a
            a = total // b
            if a >= b:                      # a >= b
                if 2*a + 2*b == brown + 4:  # 수학 수식
                    return [a,b]
            
    return answer
-----------------------------------------------------------------------------------------------------
타겟 넘버
확실히 dfs, bfs 논리적으로 생각좀 하면서 풀자.. ㅅㅂ..

from collections import deque

def solution(numbers, target):
    answer = 0
    
    q =deque()
    q.append((0,numbers[0]))
    q.append((0,-numbers[0]))
    
    c = 0
    
    while q:
        i, a = q.popleft()
          
        if i == len(numbers) -1:
            if a == target:
                c += 1      
        else:       
            q.append((i+1, a + numbers[i+1]))
            q.append((i+1, a - numbers[i+1]))
                
    return c

-----------------------------------------------------------------------------------------------------
네트워크
그래프 노드를 n개까지 범위로 반복문 돌려야했다..

dfs
def solution(n, computers):            
    
    def DFS(i):
        visited[i] = 1
        for a in range(n):
            if computers[i][a] and not visited[a]:
                DFS(a)      
                
    answer = 0
    visited = [0 for i in range(len(computers))]
    for i in range(n):
        if not visited[i]:
            DFS(i)
            answer += 1
        
    return answer

bfs
from collections import deque

def solution(n, computers):            
    
    def BFS(i):
        q = deque()
        q.append(i)
        while q:
            i = q.popleft()
            visited[i] = 1
            for a in range(n):
                if computers[i][a] and not visited[a]:
                     q.append(a)
                
    answer = 0
    visited = [0 for i in range(len(computers))]
    for i in range(n):
        if not visited[i]:
            BFS(i)
            answer += 1
        
    return answer
--------------------------------------------------------------------------------------------------------------
설탕배달
dp또는 그리디
생각보다 되게 간단하게 풀릴 수도 있다.
이미 한번 나온수면, 방문한거로 체크!!

내 풀이 - dp
import sys
from collections import deque

input = sys.stdin.readline
n = int(input())

visit = [0] * n
s = 0

q = deque()
c = 0
q.append((s, c))

result = []
while q:
  x, y = q.popleft()
  if x ==n:
    print(y)
    break

  if x < n and visit[x] ==0:
    y+=1
    visit[x] = 1
    q.append((x+5, y))
    q.append((x+3, y))
else:
  print(-1)

다른 풀이 - 그리디
sugar = int(input())

bag = 0
while sugar >= 0 :
    if sugar % 5 == 0 :  # 5의 배수이면
        bag += (sugar // 5)  # 5로 나눈 몫을 구해야 정수가 됨
        print(bag)
        break
    sugar -= 3  
    bag += 1  # 5의 배수가 될 때까지 설탕-3, 봉지+1
else :
    print(-1)
--------------------------------------------------------------------------------------------------------------
1로 만들기
dp는 역시 무조건 dfs, bfs는 아니다!
메모이제이션으로 이전값만 저장한다는 개념 가져가자!

n = int(input())

dp = [0] * (n+1)

for i in range(2, n+1):
    dp[i] = dp[i-1] + 1 # 무조건 1은 빼야하므로 횟수추가

    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2]+1) # 2로 나눠지면, 기존횟수랑 나누어떨어지는 횟수 중 작은값
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1) # 3으로 나눠지면, 기존횟수랑 나누어떨어지는 횟수 중 작은값

print(dp[n])
--------------------------------------------------------------------------------------------------------------
피보나치 함수
# 동적 계획법 (Dynamic Programming)
 - Recursive + Memorization
 - 순서를 직접 써서, 점화식 찾자!
   -> 작은 문제의 해를 테이블에 저장한 뒤, 나중에 읽어서 사용
 - 상향식 (작은 -> 큰) <-> 하향식 (분할 정복)
 - 대표적인 예로 피보나치 수열이 있다.

# 일반 풀이
def fib(N):
    zeros=[1,0,1] # 예시 3 이외부터 시작
    ones=[0,1,1]
    if N >= 3:
        for i in range(2,N):
            zeros.append(zeros[i-1] + zeros[i]) # 0의 피보나치 순서를 추가
            ones.append(ones[i-1] + ones[i]) # 1의 피보나치 순서를 추가
    print(f"{zeros[N]} {ones[N]}") # 출력
 
T = int(input())
for _ in range(T):
    N = int(input())
    fib(N)

# 숏코딩 풀이 - 와 이건 사람이 아니네 생각하는게;
T = int(input())
for _ in range(T):
    N = int(input())
    zero,one=1,0 # zero: 0개수, one: 1개수
    for i in range(N):
        zero,one = one,zero+one # zero와 one에 그 자체로 피보나치적용
    print(zero,one)
--------------------------------------------------------------------------------------------------------------
토마토
이 문제의 핵심은 여러 곳에서 시작하는 bfs였음!!
그래서 모든 좌표에서 1일때 큐에 박고시작함!!
matrix[nx][ny] = matrix[x][y] + 1 # 최소 횟수 전염되는거 기억!

import sys

input = sys.stdin.readline

from collections import deque

m, n = map(int, input().split())
matrix = [list(map(int, input().split())) for _ in range(n)]
queue = deque([])
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]
res = 0

for i in range(n):
    for j in range(m):
        if matrix[i][j] == 1:
            queue.append([i, j]) # 기존과 다르게 일단 박고 시작함.

def bfs():
    while queue:
        x, y = queue.popleft()
        for i in range(4):
            nx, ny = dx[i] + x, dy[i] + y
            if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 0:
                matrix[nx][ny] = matrix[x][y] + 1 # 최소 횟수 전염되는거 기억!
                queue.append([nx, ny])

bfs() # 박은 큐들을 시작
for i in matrix:
    for j in i:
        if j == 0:
            print(-1)
            exit(0) # 두개 반복문 바로 탈출 = 종료
    res = max(res, max(i)) # 모든 배열 중 가장 최댓값
print(res - 1)
--------------------------------------------------------------------------------------------------------------
계단오르기
마지막계단을 무조건 밟아야해서, 올라 가는거말고, 아래에서부터 올라온다고 생각하기!
이런 사고의 전환을 길러야한다!

import sys

input = sys.stdin.readline

N = int(input())

stair = [0]
for _ in range(N):
    stair.append(int(input()))

if N == 1: 
    print(stair[1])
else:
    dp = [0] * (N+1) 
    dp[1] = stair[1] #첫번째 계단
    dp[2] = stair[1] + stair[2] #두번째 계단

    for i in range(3, N+1): # 세번째부터 지정
        # 한칸 이전에서 올라올때는 그 칸에서 아래아래까지 더해줌, 두칸 이전에서는 상관없음
        dp[i] = max(dp[i-3]+stair[i-1]+stair[i], dp[i-2]+stair[i])  

    print(dp[N])
--------------------------------------------------------------------------------------------------------------
2×n 타일링
dp는 점화식이면 끝이다!
뭘 어쩔지 모를땐 늘 그렇듯 그림을 그리자!

import sys
input = sys.stdin.readline

n = int(input())
dy = [0]*(n+1)

if n == 3:
    print(n)

else:
    dy[1] = 1
    dy[2] = 2

    for i in range(3,n+1):
        dy[i] = dy[i-1]+dy[i-2] # 점화식으로 그려서, 세로로 하나 세워졌을떄와 가로로 두개 엎어져있을때 나열을 더해준다.

    print(dy[n]%10007)
--------------------------------------------------------------------------------------------------------------
가장 긴 증가하는 부분 수열

import sys

input = sys.stdin.readline

n = int(input())  # 수열의 길이
array = list(map(int, input().split()))  # 주어진 수열

# 처음에는 전부 각각 본인만 취급, 1로 초기화
dp = [1] * n

for i in range(1, n): # 두번째원소부터 비교
    for j in range(0, i): # 첫원소부터 i이전까지 비교군
        if array[j] < array[i]: # 현재원소보다 작은게있다면
            dp[i] = max(dp[i], dp[j] + 1) # 가장 큰 횟수 + 1 값이 현재수보다 작은 갯수가됨.

# 각 원소는 본인보다 작은 증가수열값, 그 중 최대값 출력
result = max(dp)
print(result)
--------------------------------------------------------------------------------------------------------------
쉬운 계단수
dp는 역시 제발 일단 모르겠으며어어어어언~~~ 일단 규칙이나 점화식을 찾아봐 제에에발!!!!!!!!!!!!!!!!!!!!
[아이디어]
1) 다루는 수가 꽤나 커서 직접 모든 자리수를 탐색할 수는 없다.
2) 한 자리일 때부터, 자리 수가 늘어날 때마다 이전 자리 수에서의 계단 수를 기준으로 몇 개가 만들어지는지 구한다.

import sys
input = sys.stdin.readline

n = int(input()) 

dp = [[0 for i in range(10)] for j in range(101)] # 최대

for i in range(1, 10): # 자리가 1자리면, 처음은 말고 뒤에 1로채움
    dp[1][i] = 1
for i in range(2, n + 1): # 자리가 2번째부터 시작
    for j in range(10): 
        if j == 0: # 끝자리가 0인거
            dp[i][j] = dp[i - 1][1] # 그대로내려오기
        elif j == 9:# 끝자리가 9인거
            dp[i][j] = dp[i - 1][8] # 9는 끝자리라 대각선 한개만 그래서 8번째
        else: # 점화식 비교하면 대각선 양쪽 방향 더한거
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
print(sum(dp[n]) % 1000000000)
--------------------------------------------------------------------------------------------------------------
연속합
아니 이렇게 간단하게 나오는게 말이돼?? 하 개현타오네,,,
일단 빡구현이 아니면, 문제상 코드가 길수가없는듯,,,
"주어진 배열에 있어서 최대(최선)의 선택을 해야하니깐... max함수를 이용한 DP문제가 아닐까?
DP 문제는 항상 규칙을 찾고 수열이 주어졌을 때,
DP 배열을 구성할 똑같은 크기의 수열이 필요하단 사실이 중요함!!!

import sys
input = sys.stdin.readline

n = int(input())

arr = list(map(int, input().split()))
dp = [0] * len(arr)
dp[0] = arr[0]

for i in range(1, len(arr)):
    dp[i] = max(arr[i], dp[i-1] + arr[i]) # 더하다 음수가 나오면, 그냥 해당 원소로 교체

print(max(dp))
--------------------------------------------------------------------------------------------------------------
포도주 시식
역시 순서대로 규칙 찾아서 점화식 찾는게 근본이다,, 근데 그게 어렵지,,,시바
계단오르기 문제같이, 앞에서 순서대로 마셔가는게아니라, 내 기준 이전에 와인을 몇개마실지 정해야한다.
이런 사고의 전환이 언제 길러질까,, 답답하다 진짜 명윤아,,

import sys
input = sys.stdin.readline

n = int(input())
wines = [0] + [int(input()) for _ in range(n)] + [0]
dp = [0] * (n+2)
dp[1] = wines[1]
dp[2] = dp[1] + wines[2]

for i in range(3, n+1):
    dp[i] = max(dp[i-3]+wines[i-1]+wines[i], dp[i-2]+wines[i], dp[i-1])
print(dp[n])
--------------------------------------------------------------------------------------------------------------
벽 부수고 이동하기
와 벽부수고 안부수고를 visit 3차원 행렬로 표시함,, 대단,,
visit = [[[0]*2 for _ in range(m)] for _ in range(n)] # 3차원 visit 스킬
웬만하면 visit 이용하는습관 들이자,, 다 쓰는 이유가 있으니깐,, ㅇㅋ?

N과 M의 범위가 1 이상 1000 이하이기 때문에 브루트포스 방식도 불가능했고,
최단거리를 만들기 위한 벽을 찾는 방법을 찾는 것도 잘 안떠오름
모든 작업을 한 번의 BFS 탐색을 통해 처리해야했기 때문에, 최적의 벽을 '탐색'하는 것보다는 '기록'하는 방식이 필요했드아,,

import sys
from collections import deque

input = sys.stdin.readline

n, m = map(int, input().split())
graph = []

# 3차원 행렬을 통해 벽의 파괴를 파악함. visited[x][y][0]은 벽 파괴 가능. [x][y][1]은 불가능.
visited = [[[0] * 2 for _ in range(m)] for _ in range(n)]
visited[0][0][0] = 1

for i in range(n):
    graph.append(list(map(int, input())))

# 상하좌우
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

def bfs(x, y, z):
    queue = deque()
    queue.append((x, y, z))

    while queue:
        a, b, c = queue.popleft()
        # 끝 점에 도달하면 이동 횟수를 출력
        if a == n - 1 and b == m - 1:
            return visited[a][b][c]
        for i in range(4):
            nx = a + dx[i]
            ny = b + dy[i]
            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue
            # 다음 이동할 곳이 벽이고, 벽파괴기회를 사용하지 않은 경우
            if graph[nx][ny] == 1 and c == 0 :
                visited[nx][ny][1] = visited[a][b][0] + 1
                queue.append((nx, ny, 1))
            # 다음 이동할 곳이 벽이 아니고, 아직 한 번도 방문하지 않은 곳이면
            elif graph[nx][ny] == 0 and visited[nx][ny][c] == 0:
                visited[nx][ny][c] = visited[a][b][c] + 1
                queue.append((nx, ny, c))
    return -1

print(bfs(0, 0, 0))
