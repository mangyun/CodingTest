그래도 푸니까 기분은 좋네

그리디, 완전 ,너비, 깊이 탐색
못하겠으면 일단 말로 풀어서쓰고해라
디버깅할때는 print로 먼저 봐바라

제일 중요한거~!!!!!!!!!!!!!!!!!!!!
- dfs, bfs에서 먼저 범위 벗어난 경우부터 무시하고, 그 다음 장애물일때 무시하게 코드짜라. 
이렇게안하면 index에러남!
- bfs같은 최단거리에서 시작점이 계속 더해지기때문에 visited 하는듯

그리디 - 최소, 최대 같은 문제
DFS, BFS
1. 일단 기본적으로 graph를 초기화할때, 노드가 1이 일반적이라 [ [노드 0번째 공백], [2,3,8], [1,3] ]
위와같이 0번째는 공백으로두고 지정한다.
2. 방문하기전에는, 위에서 인덱스 노드 0번째는 없으니까 visited = [False] * (n+1)
dfs  
- 재귀함수, 스택구조
bfs - from collections import deque
- 최소, 최단거리 구하기같은데 많이  사용
- 첫 방문처리 후, 꺼내고, 시작 - 덱, 큐구조

📍 DFS, BFS 모두 적합한 유형
단순히 모든 정점을 방문하는 것이 중요한 문제인 경우 어떤 것을 택해도 된다.

📍 DFS가 적합한 유형
모든 노드를, 왼쪽 위부터 오른쪽으로 하나씩 전부확인하면서 방문 안했으면 시작한다.
global 전역변수 자주 쓴다.
검색 대상 그래프가 큰 경우(정점과 간선의 개수가 많음)
경로의 특징을 저장해둬야 하는 문제
ex) 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는 데 
경로에 같은 숫자가 있으면 안된다는 문제, BFS는 경로의 특징을 가지지 못함

📍 BFS가 적합한 유형
가장 빠른, 가장 짧은 등 최단거리를 구해야 할 경우
DFS는 처음으로 발견되는 해답이 최단거리 라는 것 보장 X
반면 BFS는 현재 노드에서 가까운 곳부터 찾기 때문에 경로 탐색 시 
첫번째로 찾아지는 해답이 곧 최단거리이다.

#2차원 리스트 맵 정보 입력받기
n, m = map(int, input().split())
graph = []
for i in range(n):
  graph.append(list(map(int, input().split())))

#리스트 컴프리헨션
data = [[0]*4 for _ in range(3)]
print(data)

#입력
n = int(input())
data = list(map(int, input().split()))
 
# 입력이 매우 많다면
import sys
input = sys.stdin.readline
n, m = map(int, input().split())    
a = [list(map(int, input().split())) for _ in range(n)]

#줄바꿈 없애기
print(7, end=" ")
print(8, end=" ")

#걍 바로 문자열 편하게 출력, f 붙임
answer = 7
print(f"정답은 {answer}입니다.")

#걍 무시처리 
if score >= 80:
     pass

#함수처리
a = 10
def func():
  print(a)
func()

#람다 - 한줄에 함수 작성 쌉가능
print((lambda a, b: a+b)(3,7))

#람다 자주 사용하는 키 기준 정렬
array = [('홍길동', 50), ('이순신', 15), ('아무개', 54)]
print(sorted(array, key = lambda x: x[1]))

# 자주쓰는 라이브러리
내장 - min, sum, max, eval(계산)

itertools - 순열, 조합 모든 경우의 수 간단하게 쌉가능
1. 순열
from itertools import permutations
data = ['a', 'b', 'c']
result = list(permutations(data, 3)) # 모든 순열 구하기
print(result)
2. 중복 허용 순열
from itertools import product
data = ['a', 'b', 'c']
result = list(product(data, repeat = 2)) # 중복 허용 순열
print(result)
3. 중복 허용 조합
from itertools import combinations_with_replacement
data = ['a', 'b', 'c']
result = list(combinations_with_replacement(data, 2)) # 중복 허용 조합
print(result)

heapq - 힙, 우선순위 큐

bisect - 이진탐색

collections - 덱, 카운터
#리스트같은 내부에 원소 갯수 세주기
from collections import Counter
counter = Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])
print(counter['blue'])#원소 블루 갯수
print(dict(counter))#사전 자료형으로 변환

math - 수학



--------------------------------------------------------------------------------------------------------------
문제들 정리

백준
동전 0
for i in reversed(range(n)): - 순서 반대로 내려감

회의실  
끝나는 시간기준 먼저 정렬, 빨리 끝날수록 뒤에서 고려해볼 회의가 많기 때문이다. 
빨리 시작하는 순서대로 정렬을 우선 한다면, 오히려 늦게 끝날 수 있기 때문이다.
끝나는시간이 같은경우, 그걸 다시 시작시간 기준으로 정렬해야한다.
time.sort(key = lambda x: (x[1], x[0]))- 끝나는 시간 x[1]기준 먼저 오름차순 후, 
그 정렬값을 시작시간으로 다시 정렬, 내림차순은 -를 붙임


보물 
배열 복사는 .copy()
인덱스 받기는 .index(값)
배열 원소빼기는 .pop(인덱스) -> 인덱스 안쓰면 마지막 원소 나가리
혹은 del list(인덱스)

잃어버린 괄호
문자열 슬라이싱, 입력할때 split으로 구분하는 것
-----------------------------------------------------------------------------------------------------------

30
리스트를 문자열로 - ''.join(s)
각 자리 수의 합이 3의 배수
-----------------------------------------------------------------------------------------------------------
알파벳체크
if a.isalpha():
  ~~
-----------------------------------------------------------------------------------------------------------
셀프넘버
숫자 각 자릿수 = for j in str(n)
set - 차집합가능, 순서섞임, 자료형 중복제거 필터로 종종 사용
set은 추가할때 add,  list는 append
set내림차순은 sorted(셋, reverse=True)
-----------------------------------------------------------------------------------------------------------
한수
주접떨지말고 횟수 count나 하자
숫자 각 자릿수 떼는거 ㅈㄴ게 나온다.. 진짜.. 
-----------------------------------------------------------------------------------------------------------
ATM
리스트 값 하나씩 제외하면서 더하기 - answer += sum(P[:i])
내 답 = s += sum(m)  m.pop(-1)
-----------------------------------------------------------------------------------------------------------
바이러스 
다시해보기
DFS/BFS 풀이 중 어떤 문제는 visited 체커를 사용하는 반면 안하는 문제도 있는 것 같다.
그 차이에 대해 이해하려면 좀 더 많이 풀어봐야할 듯 하다
n = int(input())		# 컴퓨터의 수
m = int(input())		# 연결된 컴퓨터 쌍의 수

# 인접리스트 graph 선언 및 입력받기
graph = [[] for _ in range(n+1)]
for _ in range(m):							# 연결된 컴퓨터 쌍의 수만큼 반복
    x, y = map(int, input().split())		
    graph[x].append(y)
    graph[y].append(x)

visited = [0] * (n+1)	# 방문처리 : 방문한 컴퓨터 수를 출력해야하므로 visited 에 True/False가 아닌 0/1로 처리

def dfs(graph, v, visited):
    visited[v] = 1
    for i in graph[v]:
        if visited[i] == 0:
            dfs(graph, i, visited)
    return True

dfs(graph, 1, visited)
print(sum(visited)-1)	# 방문한 컴퓨터 개수 - 1번 컴퓨터


-----------------------------------------------------------------------------------------------------------


덩치
if i[0] < j[0] and i[1] < j[1]:
      rank += 1
무조건 오름차순 이딴게 아니라, 순수 앞뒤 비교만함
for i in range(n):
  a, b = map(int, input().split())
  m.append((a, b)) // map을 바로 append에 못 박음


유기농배추
- sys.setrecursionlimit(10000) 를 입력하지 않으면 런타임 오류가 발생한다.
- 파이썬의 기본 재귀 한도는 1000이고, 재귀 깊이가 1000을 넘어갈 경우 모듈을 추가해야 한다
- BFS로 풀면 런타임 오류가 발생하지 않는다고 한다
- graph의 index를 사용할 때 행과 열을 바꿔줘야 한다는 걸 잊지 말자
- graph[ny][nx]를 확인하고 -1로 변경해서 체커 역할을 한다
- x, y 위치를 지정할 때 헷갈리지 않도록 주의하도록 하자
BFS 풀이도 연습해둬야 하겠다
출력을 횟수 연속으로 할때, 답 산출은 노상관인듯?

-----------------------------------------------------------------------------------------------------------
숨바꼭질
and로 조건 주면 순차적으로 확인.
가장 짧은, 가장 빠른과 같은 것을 물어보면 BFS를 생각하자.
그리고 파이썬에서 queue는 반드시 deque를 사용해야 한다.
0은 False이고, 이외는 다 True
max = 10 ** 5 - 제곱은 **
for i in (x-1, x+1, x*2): - 이런문법 알아두자
visited = [0] * (max+1) - 인덱스는 -1되니까 +1 먼저해주자.
-----------------------------------------------------------------------------------------------------------
체스판 다시 칠하기
8X8범위만큼 가능한 모든 경우의 수를 검사하면 된다.
브루트포스 문제들이 늘 그렇듯이 조건 하나만 틀려도 와장창이니 주의할것....
체스판 색 인덱스의 합( k +j )
위와 같이, 인덱스의 합이 짝수인지 홀수인지로 체크무늬를 판단 할 수 있다.
요약
for i in range(N-7):
    for j in range(M-7):
        first_W = 0
        first_B = 0
        for k in range(i,i+8):
            for l in range(j,j + 8):
                if (k + l) % 2 == 0:
	----생략 ---
-----------------------------------------------------------------------------------------------------------
영화배우 숌
브루트 포스는 단순히 그냥 가능한 경우의 수를 전부 때려박는 알고리즘이다.
범위 지정 못할때, while 사용
나는 10*6이정도 범위로 for문을 사용했지만...
while N:
    movie += 1
    if "666" in str(movie):
        N -= 1
print(movie - 1)

연산자 끼워넣기
음수 % 양수의 몫 = int(음수 / 양수)
------------------------------------------------------------------------------------------------------------
스타트와 링크
참고
set에서의 차집합 이외로도, 아래처럼 인덱스로도 분리가능.
team1 = team[i] # team
team2 = team[-i-1] # team[i]와는 반대 원소로 이루어짐

from itertools import combinations as c # 이렇게 c 로 치환

n = int(input())
array = [i for i in range(n)]
matrix = []
for _ in range(n):
    matrix.append((list(map(int, input().split()))))
result = int(1e9)
for r1 in c(array, n//2):
    start, link = 0, 0
    r2 = list(set(array) - set(r1)) # set을 써서 차집합으로 나머지 원소 구하기
    for r in c(r1, 2):
        start += matrix[r[0]][r[1]]
        start += matrix[r[1]][r[0]]
    for r in c(r2, 2):
        link += matrix[r[0]][r[1]]
        link += matrix[r[1]][r[0]]
    result = min(result, abs(start-link))
print(result)
-----------------------------------------------------------------------------------------------------------
섬의개수
참고
대체 visited같은 체커는 언제쓰는가?
다시 풀어보니 그냥 visit 안쓰고 했고, 이번엔 가로 세로 구분 잘해서 넣었다. 

1. 예전 dfs 버전
import sys
sys.setrecursionlimit(5000000)

input = sys.stdin.readline

def dfs(x,y):
  if 0 <= x < h and 0 <= y < w:# 가로 높이 구분 잘 해서 넣기
    if g[x][y] == 1:
      g[x][y] = 2
      for i in (-1 , 0 , 1): # 범위 지정 이건 잘한듯 ㅇㅇ
        for j in (-1 , 0 , 1):
          dfs(x+i, y+j)
      return True
  return False

while True:
  w, h = map(int, input().split()) # 이거 가로, 높이 구분 잘하자 제발!!

  if w == 0 and h ==0:
    break
  g = [list(map(int, input().split())) for _ in range(h)]
  
  c = 0
  
  for i in range(h): # 가로 높이 구분 잘 해서 넣기
    for j in range(w):
      if g[i][j] == 1:
        dfs(i,j)
        c += 1
             
  print(c)

2. bfs로 오랜만에 다시 풀어봄.
import sys

input = sys.stdin.readline

from collections import deque

dx, dy = [-1,1,0,0,-1,-1,1,1], [0,0,-1,1,1,-1,1,-1]

def bfs(a,b):
    q = deque()
    q.append((a,b))
   
    while q:
      x, y = q.popleft()
  
      for i in range(8):
        nx = x + dx[i]
        ny = y + dy[i]
  
        if 0<= nx < h and 0<= ny < w:
          if g[nx][ny] == 1:
            g[nx][ny] = 0
            q.append((nx,ny))

while True:
  w, h = map(int, input().split())

  if w== 0 and h ==0:
    break
  
  g = [list(map(int, input().split())) for _ in range(h)]
  
  c = 0 
  for i in range(h):
    for j in range(w):
      if g[i][j] == 1:
        g[i][j] = 0
        bfs(i,j)
        c+= 1
  
  print(c)
-----------------------------------------------------------------------------------------------------------
부분수열의 합
참고 
list(combinations(s, n))으로도 쉽게풀었지만,
dfs를 이용하여 재귀적으로 푼 풀이 
해당원소를 포함하는 경우/ 포함하지 않는경우로 인덱스가 늘어감에따라 가지가 뻗어나가는 형태

import sys
input = sys.stdin.readline
def dfs(idx, sum):
    global cnt
    if idx >= n: # 인덱스가 범위를 나가면 리턴
        return
    sum += s_[idx] # 현재 값을 더해주기
    if sum == s: # 원하는 값이면
        cnt += 1 # 카운트
    dfs(idx + 1, sum - s_[idx]) # 현재값을 뺀, 다음 인덱스를 시작
    dfs(idx + 1, sum) # 현재값을 그대로 더한, 다음 인덱스를 시작

n, s = map(int, input().split())
s_ = list(map(int, input().split()))
cnt = 0
dfs(0, 0)
print(cnt)
-----------------------------------------------------------------------------------------------------------
안전영역
참고 
이차원 최대,최소 구하기 = 개꿀!
graph_min = min(map(min, graph))    # min_height
graph_max = max(map(max, graph))    # max_height

import sys 
sys.setrecursionlimit(5000000) # dfs할때 무조건 박아라.
input = sys.stdin.readline

def dfs(x,y):
  if 0<= x < n and 0<= y < n:
    if z[x][y] > i and visit[x][y] == 0:
      visit[x][y] = 1
      dfs(x,y-1)
      dfs(x-1,y)
      dfs(x+1,y)
      dfs(x,y+1)
    return True  # True랑 False는 딱히 쓸거 아니면 없어도 상관은 없다.
  return False 
  
n = int(input())
z = [list(map(int, input().split())) for _ in range(n)]

k = max(map(max, z)) # 2차원 원소 최대값 -> 이거개꿀이다

count = []
for i in range(k): # (q, k) 괜히 최솟값부터 시작하려했다가 ㅈㄴ 런타임 벨류 에러남.
  c = 0
  visit = [[0] * n for _ in range(n)] # 초기화 무조건해야함
  for x in range(n):
    for y in range(n):
      if z[x][y] > i and visit[x][y] == 0:
        dfs(x,y)
        c += 1
        
  count.append(c)        
print(max(count))

-----------------------------------------------------------------------------------------------------------
날짜계산
import sys 

input = sys.stdin.readline

e = s = m = count = 1
a, b, c = map(int, input().split())

while 1:
  if e == a and s == b and c == m:
    break   
  e += 1 ;s += 1 ;m += 1;count += 1
  if e > 15 :e -= 15
  if s > 28:s -= 28
  if m > 19:m -=19
   
print(count)
-----------------------------------------------------------------------------------------------------------
나이트의 이동

import sys 
from collections import deque
input = sys.stdin.readline

t = int(input())

dx, dy = [-2,-2,-1,-1,1,1,2,2], [1,-1,2,-2,-2,2,1,-1]

def bfs(x, y):
  q = deque()
  q.append((x,y))
  
  while q:
    x, y = q.popleft()
    
    if x == a and y == b:
        return g[x][y] 
  
    for i in range(8):
      nx = x + dx[i]
      ny = y + dy[i]

      if 0<= nx < n and 0<= ny <n:
        if g[nx][ny] == 0:
          g[nx][ny] = g[x][y] + 1
          q.append((nx,ny))
          
for i in range(t):
  n =  int(input())
  x, y = map(int, input().split())
  a, b = map(int, input().split())
  g = [[0]*n for _ in range(n)]
  print(bfs(x,y))
 
-----------------------------------------------------------------------------------------------------------
로프

import sys 

input = sys.stdin.readline

n = int(input())
m = [int(input()) for _ in range(n)]

m.sort()

print(m)
for i in range(n):
  m[i] *= n-i

print(max(m))
-----------------------------------------------------------------------------------------------------------
영역구하기
참고
채우면서 count를 증가시키고 영역을 모두 채웠다면 그 count를 cnt에 저장해준다.
len(영역의 개수) = cnt의 갯수
이런 면적 찾는문제는 BFS

m, n, k = map(int, input().split())
s = [[0] * n for i in range(m)]
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
cnt = []
for i in range(k):
    x1, y1, x2, y2 = map(int, input().split())
    for j in range(y1, y2):
        for k in range(x1, x2):
            s[j][k] = 1
for i in range(m):
    for j in range(n):
        if s[i][j] == 0:
            count = 1
            s[i][j] = 1
            queue = [[i, j]]
            while queue:
                x, y = queue[0][0], queue[0][1]
                del queue[0]
                for k in range(4):
                    x1 = x + dx[k]
                    y1 = y + dy[k]
                    if 0 <= x1 < m and 0 <= y1 < n and s[x1][y1] == 0:
                        s[x1][y1] = 1
                        count += 1
                        queue.append([x1, y1])
            cnt.append(count)
print(len(cnt))
cnt.sort()
for i in cnt:
    print(i, end=' ')

-----------------------------------------------------------------------------------------------------------

프로그래머스
오픈채팅방
def solution(record):
    answer = []
    uid = {} #dic형태로 아이디번호 : 이름으로 박음
    result = []
    
    for str in record:
        t = str.split() # 공백을 기준으로 단어 쪼갬
        if t[0] == 'Enter':
            uid[t[1]] = t[2]
            result.append([t[1], '님이 들어왔습니다.'])
        elif t[0] == 'Leave':
            result.append([t[1], '님이 나갔습니다.'])
        else:
            uid.update({t[1]:t[2]}) # 업데이트 사용
            
    for i in result:
        i[0] = uid.get(i[0]) # 딕셔너리 받음
        s = ''.join(i) # 리스트를 문자열로 합치기
        answer.append(s)
            
    return answer

딕셔너리
update: 키의 값 수정, 키가 없으면 키-값 쌍 추가
popitem(), pop(키)  키-값 쌍 삭제하기
clear()모든 키-값 쌍을 삭제하기
get(키) 키의 값을 가져오기
items: 키-값 쌍을 모두 가져옴
keys: 키를 모두 가져옴
values: 값을 모두 가져옴
-----------------------------------------------------------------------------------------------------------
깔끔한 dfs 방문
sys.setrecursionlimit(5000) #재귀에러 방지
input = sys.stdin.readline

# dfs로 그래프를 탐색한다.
def dfs(start, depth):

    #해당 노드 방문체크 한다.
    visited[start] = True

    # 해당 시작점을 기준으로 계속해서 dfs로 그래프를탐색한다.
    for i in graph[start]:
        if not visited[i]:
            dfs(i, depth + 1)

깔끔한 bfs 방문
import sys
from collections import deque

input = sys.stdin.readline

def bfs(start):
    queue = deque([start])
    visited[start] = True
    while queue:
        node = queue.popleft()
        for i in graph[node]:
            if not visited[i]:
                visited[i] = True
                queue.append(i)

거리두기
이렇게 각각의 P마다 bfs를 수행하여 그 대기실의 모든 P가 거리두기를 잘 지킨다면
그 대기실에 1을 표시한다.
-----------------------------------------------------------------------------------------------------------
신고 결과 받기
코드이외참고 
from collections import defaultdict
report = set(report)
    user_list_who_i_report = defaultdict(set)
    num_of_reported = defaultdict(int)
Defaultdict는 value의 타입만 지정해준다면 key에 매핑되는 값을 하나하나 지정해주지 않아도 
자동으로 기본값이 들어가있다.

def solution(id_list, report, k):
    answer = [0] * len(id_list) 
    report = set(report) #핵심 !! 동일인물에게 한번만 신고가능해서, set으로 중복 제거
    lst = {} 
    check = {}
    
    for s in report:
        a, b = s.split(' ') # 공백을 기준으로 나눔 
        
        if b not in check: # 신고받은 내용이 아직 없다면
            check[b] = 1 # 한번 저장
        else:
            check[b] += 1 #있으면 한번 추가
            
        if a not in lst: # 누가 누굴 신고했는지 저장
            lst[a] = [b]
        else:
            if b not in lst[a]:
                lst[a] += [b] # 걍 딕셔너리 value 추가는 + 기호임
                
    for id_, n  in check.items(): # dic.items()는 키, value 전부 꺼내옴
        if n >= k: 
            for user, user2 in lst.items():
                if id_ in user2:
                    answer[id_list.index(user)] += 1 # index메소드는 list.index(값) 이런식으로 사용
    return answer
-----------------------------------------------------------------------------------------------------------
신규 아이디 추천
참고
# 문자열의 첫글자만 대문자로 변경, 문자열의 모든 단어들의 첫글자를 대문자로 변경
capitalize(), title()
ord = 문자를 숫자로, chr = 숫자를 문자로, str - 문자열로
str1 = str1.upper()
str2 = str2.upper() - 대문자로 변환
# 문자열 알파벳 모두 소문자인지 대문자인지, 서로 반전
islower(), isupper(), swapcase()
관련 함수 : string.upper(), stirng.isupper(), string.islower()
string.isalnum() - 문자열이 모두 숫자일 경우 true 리턴
string.isalpha() - 문자열이 모두 한글이나, 영어일 경우 true 리턴
isdigit() - 숫자인지

string.replace() - replace(old, new, [count]) -> replace("찾을값", "바꿀값", [바꿀횟수])
ex) text = '123,456,789,999'
replaceAll= text.replace(",","") #123456789999
replace_t2 = text.replace(",", "",2) #123456789,999
string.find("..") - ..인 문자열 찾기

def solution(new_id):
    answer = ''
    # 1
    new_id = new_id.lower() # 대문자를 소문자로
    # 2
    for c in new_id: 
        if c.isalpha() or c.isdigit() or c in ['-', '_', '.']: # isalpha(), isdigit(), in 사용
            answer += c
    # 3
    while '..' in answer: # 문장에서 ..이 나오는 부분은
        answer = answer.replace('..', '.') # answer.replace('..', '.') 앞에꺼를 뒤에꺼로 바꿈
    # 4
    if answer[0] == '.': #처음에 마침표갸 .이면
        answer = answer[1:] if len(answer) > 1 else '.' # 문자열 1개면 index 에러, 이 조건 넣어줘야함
    if answer[-1] == '.':#마지막에 마침표가 .이면
        answer = answer[:-1] # 마지막 하나자르기
    # 5
    if answer == '': # 빈문자열이면 a 넣기
        answer = 'a'
    # 6
    if len(answer) > 15:
        answer = answer[:15] # 처음부터 15개까지만 남기기
        if answer[-1] == '.': # 마침표가 끝에 위치하면, 마침표 제거
            answer = answer[:-1]
    # 7
    while len(answer) < 3: # 길이가 3보다 작으면
        answer += answer[-1] #마지막 글자 계속 추가
    return answer
-----------------------------------------------------------------------------------------------------------
숫자 문자열과 영단어
참고
 for i,c in enumerate(arr): # enumerate 로 인덱스와 값을 한번에 받을수도 있음.
        s = s.replace(c,str(i))

def solution(s):
    answer = s 
    num_s = {'zero':0, 'one':1, 'two':2, 'three':3, 'four':4, 'five':5, 'six':6, 'seven':7, 'eight':8, 'nine':9}

    for item in num_s.items():
        answer = answer.replace(item[0], str(item[1]))   

    return int(answer)
-----------------------------------------------------------------------------------------------------------
키패드 누르기
참고
키패드 좌표를 dic에다가 박고 시작하는 경우도 있었다.
 # 키패드 좌표료 변경
    dic = {1: [0, 0], 2: [0, 1], 3: [0, 2],
           4: [1, 0], 5: [1, 1], 6: [1, 2],
           7: [2, 0], 8: [2, 1], 9: [2, 2],
           '*':[3, 0], 0: [3, 1], '#': [3, 2]}
    
    # 시작 위치
    left_s = dic['*']
    right_s = dic['#']

def solution(numbers, hand):
    answer = ''
    lastL = 10
    lastR = 12
    
    for n in numbers:
        if n in [1,4,7]:
            answer+='L'
            lastL = n
        elif n in [3,6,9]:
            answer+='R'
            lastR = n
        else:
            n = 11 if n == 0 else n # 0일때 10, 12인 거리를 빼도 같아지기 위해 11 
            
            absL = abs(n-lastL)
            absR = abs(n-lastR)
            
            if sum(divmod(absL, 3)) > sum(divmod(absR, 3)): # divmod(a, b) : a를 b로 나눈 몫과 나머지를 더하는 센스
                answer+='R'
                lastR = n
            elif sum(divmod(absL, 3)) < sum(divmod(absR, 3)):
                answer +='L'
                lastL = n
            else:
                if hand == 'left':
                    answer+='L'
                    lastL = n
                else:
                    answer+='R'
                    lastR = n
                
    return answer
-----------------------------------------------------------------------------------------------------------
크레인인형뽑기
참고
문제와는 관계없는 리스트 회전 - board = list(zip(*board[::-1]))
배열 끝부분 비교를 basket[-2] == basket[-1] -> 이게 신박한 부분이었음

def solution(board, moves):
    basket = [] # 인형들을 담아줄 바구니~
    answer = 0 # 팡 터진 인형들 계산
    
    for move in moves: # 사용자의 움직임 하나씩 출력
        for column in board: # columns 출력
        	# move는 1부터 시작하기 때문에 index로 사용하기 위해선 -1씩 해줘야 함
            if column[move-1] != 0: # 만약 column의 move가 0이 아니라면 (인형이 있다는 말)
                basket.append(column[move-1]) #해당 값을 인형 바구니에 담기
                column[move-1] = 0 # 뽑은 인형은 0 처리
                
                if len(basket) > 1: # 바구니에 인형이 2개 이상 들어가는데
                    if basket[-2] == basket[-1]: # 인형이 두개가 겹친다면
                        del basket[-2] # 터뜨린다
                        del basket[-1] # 터뜨린다
                        answer += 2 # 터뜨린 인형 갯수 추가
        
                break 
    return answer 
--------------------------------------------------------------------------------------------------------------
실패율
참고
딕셔너리는 pop같은게 안된다!!
sorted(a, key = lambda x : a[x], reverse = True) 처럼 람다 꼭 기억!!

def solution(N, stages):
    a = {} # 아 그냥 선언만해도 밑에서 a[i]처럼 ㅇㅈㄹ 할 수있구나!
    for i in range(1, N+1):
        a[i] = stages.count(i) / len(stages)
        while i in stages:
            stages.remove(i)

   return sorted(a, key = lambda x: a[x], reverse= True)
--------------------------------------------------------------------------------------------------------------
1차 비밀지도
zip 써서, 두 배열 원소 동시 비교
or |, xor ^, and & 이렇게 비트연산으로 두 수 비교, 캬 클라스~
zfill써서 앞에 부족한 수만큼 0 채워주기
이진수로 바꾸면서 0b바로없애기 -> format(s, 'b')
key point: zip(), bin(i | j), rjust()(오른쪽으로 정렬해서 왼쪽부터 채움- zfill()과 유사한 기능)

def solution(n, arr1, arr2):
    answer = []

    for i, j in zip(arr1, arr2): # zip 써서, 두 배열 원소 동시 비교
        value = str(bin(i|j)[2:]) # 와 or를 쓰는건 ㄹㅇ 천재네;;
        value = value.zfill(n)# 앞에 부족한 수만큼 0 채워주기
        value = value.replace('1', '#')
        value = value.replace('0', ' ')
        answer.append(value)

    return answer

다른풀이 zip 안쓴거!
def solution(n, arr1, arr2):
    answer = []
    
    for i in range(n):
        tmp = bin(arr1[i] | arr2[i]) # or 써버리기!
        # tmp결과 ex) '0b1101'
        tmp = tmp[2:].zfill(n)
        # tmp결과 ex) '01101'
        tmp = tmp.replace('1','#').replace('0',' ')
        # tmp결과 ex) ' ## #'
        answer.append(tmp)
    
    return answer
--------------------------------------------------------------------------------------------------------------
1차 다트게임
is.digit() - 숫자 판단
제곱은 **
배열 이전원소 stack[-1]로 제발제발제발제발제발제발 이용!!

def solution(dartResult):
    stack = []
    dartResult = dartResult.replace("10", "A") #10에 대한 예외 처리해야함, 문제좀 잘봐라,..
    bonus = {'S': 1, 'D': 2, 'T': 3} #그냥 S D T 설정
    
    for i in dartResult:
        if i.isdigit() or i=='A': # 1~9거나 10이거나
            stack.append(10 if i == 'A' else int(i)) 
        elif i in ('S', 'D', 'T'): # 이런 세 조건을 볼때 제발 in 써라!
            num = stack.pop()
            stack.append(num ** bonus[i])
        elif i == '#': # 이전꺼 -1 곱하기
            stack[-1] *= -1
        elif i == '*':
            num = stack.pop()
            if len(stack):
                stack[-1] *= 2
            stack.append(2 * num)
    return sum(stack)
---------------------------------------------------------------------------------------------------------
1차 뉴스 클러스터링
floor -> import math 해야함
intersection = set(str1) & set(str2) -> 교집합
union = set(str1) | set(str2) -> 합집합

def solution(str1, str2):
    answer = 0
    str1 = str1.upper()
    str2 = str2.upper()
    list1 = []
    list2 = []
    
    for i in range(len(str1)):
        if str1[i:i+2].isalpha() and len(str1[i:i+2]) == 2:
            list1.append(str1[i:i+2])
    
    for i in range(len(str2)):
        if str2[i:i+2].isalpha() and len(str2[i:i+2]) == 2:
            list2.append(str2[i:i+2])

    c= 0
    for i in list1: //내가 풀긴했지만 신박하게 합집합, 교집합을 풀었음
        if i in list2:
            list2.remove(i)
            c += 1
    
    if len(list1) + len(list2) == 0:
        answer = 65536
    else:
        answer = int((c / (len(list1) + len(list2)) )*65536)

    return answer

다름사람 Counter를 이용한 풀이
from collections import Counter

def solution(str1, str2):
    str1_low = str1.lower()
    str2_low = str2.lower()
    
    str1_lst = []
    str2_lst = []
    
    for i in range(len(str1_low)-1):
        if str1_low[i].isalpha() and str1_low[i+1].isalpha():
            str1_lst.append(str1_low[i] + str1_low[i+1])
    for j in range(len(str2_low)-1):
        if str2_low[j].isalpha() and str2_low[j+1].isalpha():
            str2_lst.append(str2_low[j] + str2_low[j+1])
            
    Counter1 = Counter(str1_lst)
    Counter2 = Counter(str2_lst)
    
    inter = list((Counter1 & Counter2).elements())
    union = list((Counter1 | Counter2).elements())
    
    if len(union) == 0 and len(inter) == 0:
        return 65536
    else:
        return int(len(inter) / len(union) * 65536)
---------------------------------------------------------------------------------------------------------
문자열 압축
입력 문자열의 길이가 최대 1000이었으므로 완전 탐색이 가능할 것으로 생각함.
따라서 망설임 없이 loop를 두 번 타는 걸 생각했다. → O(n^2) 풀이
for문을 1, len(s) // 2 + 1까지 반복했다. 문자열 길이 범위를 꼭 축소하자
for i in range(0, n, 2) -> 여기서 2 같은 step 변수를 무조건 써야한다.

def solution(s):
    result=[]
    
    if len(s)==1:
        return 1
    
    for i in range(1, len(s)+1):
        b = ''
        cnt = 1
        tmp=s[:i]

        for j in range(i, len(s)+i, i): # 제일중요한 i만큼 바로 건너띄기!! 
            
            if tmp==s[j:i+j]:
                cnt+=1
            else:
                if cnt!=1:
                    b = b + str(cnt)+tmp
                else:
                    b = b + tmp
                    
                tmp=s[j:j+i]
                cnt = 1
                
        result.append(len(b))
        
    return min(result)
---------------------------------------------------------------------------------------------------------
튜플
참고
s.sort(key = len) -> 길이를 기준으로 오름차순
문자를 숫자로 -> int(s)
s = s.split("},{") -> 분리시키는거!!
배열 a[-2] 자릿수 찾는거 많이쓴다 진짜!!

def solution(s):
    answer = []
    s = s[2:-2] # 양 옆 괄호들 사라짐
    s = s.split("},{") # 중간 },{를 기준으로 분리
    s.sort(key = len) # 길이를 기준으로 오름차순
    
    for i in s:
        ii = i.split(',') # 다시 ,을 기준으로 분리
        
        for j in ii:
            if int(j) not in answer:
                answer.append(int(j))
    
    return answer
------------------------------------------------------------------------------------------------------------
1차 프렌즈 4블록
문제가 굉장히 길지만, 특별한 알고리즘을 요구하는 문제가 아니다.
정사각형 모양으로만 블록이 사라지므로 BFS나 DFS도 필요하지 않다.
다만, 아래 그림과 같이 정사각형이 서로 겹칠 가능성이 있다.
set 메소드 s = {'a','b','c','d','e','f'}
s.add('g') 결과: {'c', 'e', 'b', 'd', 'g', 'a', 'f'} -> 집합은 순서가 없어요!
s.remove('a') 결과: {'c', 'e', 'b', 'd', 'g', 'f'}
s.discard('b') 결과: {'c', 'e', 'd', 'g', 'f'}
print(s.pop()) 결과: c
s.clear() 결과: set()

def solution(m, n, board):
    for i in range(m):
        board[i] = list(board[i])
    
    cnt = 0
    rm = set()
    while True:
        # 보드를 순회하며 4블록이 된 곳의 좌표를 집합에 기록
        for i in range(m-1):
            for j in range(n-1):
                t = board[i][j]
                if t == []:
                    continue
                if board[i+1][j] == t and board[i][j+1] == t and board[i+1][j+1] == t:
                    rm.add((i,j));rm.add((i+1,j))
                    rm.add((i,j+1));rm.add((i+1,j+1))
        
        # 좌표가 존재한다면 집합의 길이만큼 세주고 블록을 지움 
        if rm:
            cnt += len(rm)
            for i,j in rm:
                board[i][j] = []
            rm = set()
        # 없다면 함수 종료
        else:
            return cnt
        
        # 블록을 위에서 아래로 당겨줌
        while True:
            moved = 0
            for i in range(m-1):
                for j in range(n):
                    if board[i][j] and board[i+1][j]==[]:
                        board[i+1][j] = board[i][j]
                        board[i][j] = []
                        moved = 1
            if moved == 0:
                break

------------------------------------------------------------------------------------------------------------
트리의 부모찾기
기본적으로 반복은 1000회
sys.setrecursionlimit(500000) -> 이거 무조건 해줘야함

import sys 
sys.setrecursionlimit(500000) # 개중요함!!
input = sys.stdin.readline

n = int(input())
g = [[] for _ in range(n+1)]

for _ in range(n-1):
  a, b = map(int, input().split())
  g[a].append(b)
  g[b].append(a)

visited = [0]*(n+1)
visited[1] = 1
node = [0]*(n+1)

def dfs(start):  
  for i in g[start]:
    if visited[i] == 0:
      visited[i] = 1
      dfs(i)
    else:
      node[start] = i
    
dfs(1)

for i in range(2, n+1):
  print(node[i])
-----------------------------------------------------------------------------------------------------------
촌수 계산
그냥 전형적인 bfs, dfs 문제
시작촌수, 목표촌수 

from collections import deque
import sys
input = sys.stdin.readline
n = int(input())
a, b = map(int, input().split())
m = int(input())
adj = [[] for i in range(n + 1)]
result = [0 for i in range(n + 1)]
def bfs(start):
    q = deque()
    q.append(start)
    visit = [0 for i in range(n + 1)]
    visit[start] = 1
    while q:
        d = q.popleft()
        for i in adj[d]:
            if visit[i] == 0:
                visit[i] = 1
                result[i] = result[d] + 1 # 현재촌수 +1 값을 이동할 촌수값에 넣기
                q.append(i)
for i in range(m):
    x, y = map(int, input().split())
    adj[x].append(y)
    adj[y].append(x)
bfs(a)# 시작 촌수는 a
print(result[b] if result[b] != 0 else -1) # b가 a와 촌수가 없으면 -1
-----------------------------------------------------------------------------------------------------------\
주유소
참고
그림을 그려 차분히 로직을 생각하고 구현하는 습관을 길러야겠다.
그리디 같은 문제는 생각보다 많은 스킬이 필요하지 않을수도있다.
min값을 먼저 일단 지정하고 비교해서 바꿔줌

import sys
input = sys.stdin.readline

N = int(input())

roads = list(map(int,input().split()))
costs = list(map(int,input().split()))

# 첫번째 값 더하기
min_price = roads[0] * costs[0]

# 가장 값이 싼 주유소 지정
min_cost = costs[0]

for i in range(1, N-1): # 여기부터가 진짜중요
  if min_cost > costs[i]: # 가장 값이 싼 주유소가 현재 주유소 보다 비싸면 바꿔준다.
    min_cost = costs[i] # 값 싼 주유소로 바꿔주기
  
  min_price += min_cost * roads[i]

print(min_price)
-----------------------------------------------------------------------------------------------------------
수들의합
갯수가 최대가 되려면, 값을 넘기직전까지 1부터 더해주다가, 나머지 한개의 수로 채워주면된다.
각 sum과 count를 따로 선언해주거나, 합의공식을 이용함

s = int(input())
n = 1
while n * (n + 1) / 2 <= s:
    n += 1
print(n - 1)
-----------------------------------------------------------------------------------------------------------
30
30의 배수는 -> 3의 배수로 보고 시작한다!!
30의 배수의 조건
1. 전체 각 자리의 합이 3의배수
2. 끝이 0으로 끝나야함 

n = input()
n = sorted(n, reverse=True)
sum = 0
if '0' not in n:	# 우선은 input의 디폴트인 string으로 받았기에 '0' 문자로 적음
    print(-1)
else:
    for i in n:
        sum += int(i)
    if sum % 3 != 0 :	# 3의 배수 체크하면, 0만 붙였을때 30의 배수이다.
        print(-1)
    else :
        print(''.join(n))
-----------------------------------------------------------------------------------------------------------
모든순열
모든 순열을 탐색해서 출력하면 된다.
dfs를 통해 백트래킹을 했고 출력을 했다.
순열을 구하기 위해 위의 테크닉을 잘 알고 있으면 좋을 것 같다.

import sys
input = sys.stdin.readline
n = int(input())
temp = []

def dfs():
    if len(temp) == n: # 전체 길이가 같다면 출력
        print(temp)
        return
    for i in range(1, n + 1): 
        if i not in temp: # 1부터 하나씩
            temp.append(i) # 1추가
            dfs() # 더 깊게 들어가기, 1 제외 2 먼저 넣기, 그다음 3 넣기
            temp.pop() # 3, 2 순서로 빼고, 다시 반복문으로 가서, 이번엔 3부터 넣기

dfs()
-----------------------------------------------------------------------------------------------------------
신입사원
키 정렬할때, 그냥 sort로 하면 앞 인덱스 기준으로 정렬됨
이런 min, max 를 for문 비교과정에서 바꿀줄 아는 스킬을 길러야함.
-> 계산량을 줄이기위해!

import sys
input = sys.stdin.readline

T = int(input()) #테스트케이스

for i in range(0,T):
    Cnt = 1
    people = []
    
    N = int(input())
    for i in range(N):
        Paper, Interview = map(int,sys.stdin.readline().split())
        people.append([Paper, Interview])

    people.sort() # 서류 기준 오름차순 정렬
    Max = people[0][1] #서류는 기준으로 정렬했으므로, 면접순위 대입
    
    for i in range(1,N):
        if Max > people[i][1]: #이후사람이 면접순위가 더 높으면 
            Cnt += 1 # 채용
            Max = people[i][1] # 순위 교체

    print(Cnt)
-----------------------------------------------------------------------------------------------------------
gcd합
import math해서 math.gcd 할수도있지만, 함수로 구하는것도 알아둬라.
아래 코드는 골때리는코드, 같은 비교군에서 원소비교할때 개좋을듯?
for i in range(k):
        for j in range(k):
            if i<j : # 진행하지 않은 나머지 원소

import sys
input = sys.stdin.readline

n = int(input())

def gcd(a, b) : # 최대공약수 구하기, 아니면 import math 쓰셈 -> math.gcd
    if b==0:
        return a
    else :
        return gcd(b,a%b)

for _ in range(n):
    arr = list(map(int,input().split()))
    k = arr.pop(0) # 처음 개수는 빼버림
    sum = 0
    for i in range(k):
        for j in range(k):
            if i<j : # 진행하지 않은 나머지 원소
                sum += gcd(arr[i],arr[j])
    print(sum)

-----------------------------------------------------------------------------------------------------------
외판원 순회 2
참고
출발도시를 어디로 정하든 무조건 사이클이 발생해서 상관없기때문에, 출발지를 정하자!
res = sys.maxsize # 일단 최소비교를 위해, 처음엔 최대치로 박아놓음.
if add > res: # 일단 첫번째 루트값이 담겨있는데 두번째 루트진행시, 전체 비용도 계산안했는데, 중간 비용이 이미 최소비용보다 커버린다면 종료
      return
if sum(visited) == n-1: # 첫번째는 방문체크 안했으므로, 나머지 도시 다 방문했을때
    if g[f][0] != 0: # 값이 있다면
      res = min(res, add+g[f][0]) # 현재 res와, 마지막도시에서 첫번째로 이동할때값을 더한것과 비교
      return

import sys
input = sys.stdin.readline

n = int(input())

g = [list(map( int, input().split())) for _ in range(n)]

visited = [0] *n
res = sys.maxsize # 일단 최소비교를 위해, 처음엔 최대치로 박아놓음.

def dfs(f, add, visited):
  global res

  if add > res: # 일단 첫번째 루트값이 담겨있는데 두번째 루트진행시, 전체 비용도 계산안했는데, 중간 비용이 이미 최소비용보다 커버린다면 종료
      return
  
  if sum(visited) == n-1: # 첫번째는 방문체크 안했으므로, 나머지 도시 다 방문했을때
    if g[f][0] != 0: # 값이 있다면
      res = min(res, add+g[f][0]) # 현재 res와, 마지막도시에서 첫번째로 이동할때값을 더한것과 비교
      return

  for i in range(1, n): 
    if g[f][i] != 0 and visited[i] ==0: # 값이 있고, 아직 방문안했으면
      visited[i] = 1 
      dfs(i, add+g[f][i], visited) # 비용 더해서, 다음 도시 탐색
      visited[i] = 0
  
for i in range(1, n): # 출발지를 어디를 해도 상관이없다.
  if g[0][i] != 0: # 그래서 첫번째 도시부터 출발
    visited[i] = 1 #출발도시는 range(1, n)에서 걸러져서, 방문체크일단 안함
    dfs(i, g[0][i], visited)
    visited[i] = 0 # 방문했으면 다시 해제
  
print(res)
-----------------------------------------------------------------------------------------------------------
뒤집기
탐욕 알고리즘 -> 단순하게 시작 
길이에 관계없이 문자가 바뀌는지만 봄 -> 0001100은 010으로 봐도 무방
다음은 길이에 따라 최소 몇번 바꿔야하는지를 적은것이다.

S = input()
count = 0
for i in range(len(S)-1):
    if S[i] != S[i+1]:
        count += 1
print((count + 1) // 2)

내풀이 -> 정석이 너무 간단해서 쌉현타!
import sys
input = sys.stdin.readline

s = input()
s= s.replace(s[-1], '')

if s.split('0') > s.split('1'):
  s = s.split('1')
else:
  s = s.split('0')

a = []
for i in s:
  if i != '':
    a.append(i)

print(len(a))
-----------------------------------------------------------------------------------------------------------
A->B
참고
q.append((a,1)) # c를 같이 넣어서 횟수를 따로세줌.
 if s > b: # 크면 그 큐는 종료
    continue

import sys
input = sys.stdin.readline

a, b = map(int, input().split())

from collections import deque

q= deque()
q.append((a,1)) # c를 같이 넣어서 횟수를 따로세줌.

while q: 
  s, c = q.popleft()

  if s > b: # 크면 그 큐는 종료
    continue

  if s == b:
    print(c)
    break
    
  if s*10 +1 <= b:
    q.append((s*10 +1, c+1))
  if s*2 <= b:
    q.append((s*2, c+1))
else: # while 문에 else를 붙혀서, q가 비었다면 이라고 할수있다.
  print(-1)
-----------------------------------------------------------------------------------------------------------
문자열

import sys
input = sys.stdin.readline

a, b = input().split()

def com(a, b):
  global c
  for i in range(len(a)):
    if a[i] != b[i]:
      c+=1

c = 0
l = []

for i in range(len(b) -len(a) + 1):
  com(a, b[i:len(a)+i])
  l.append(c)
  c= 0

print(min(l))
-----------------------------------------------------------------------------------------------------------
사탕게임
그 이유는 테이블 크기가 50보다 작기 때문에 -> 완전탐색 
이문제는 브루트포스의 정석과 같은 문제이다. 
단 한번이라도 조건이 틀리면 오답이 나오니 유의해야한다.
특히 사탕색을 바꾸고 개수를 계산한다음, 다시 색을 원 상태로 돌려 놓아야 한다는 점

n = int(input())
candies=[]
ans = 1
 
for i in range(n):
    temp =[]
    temp_str = input()
    for j in range(n):
        temp.append(temp_str[j])
    candies.append(temp)
    

    
# 몇개 먹을 수 있는지 찾는 함수
def search():
    global ans
    for i in range(n):
        cnt = 1
        for j in range(n-1):
            if candies[i][j]== candies[i][j+1]:
                cnt+=1
                ans = max(cnt,ans)
            else:
                cnt = 1
        #ans = max(cnt,ans)
        
    for i in range(n):
        cnt = 1
        for j in range(n-1):
            if candies[j][i] == candies[j+1][i]:
                cnt+=1
                ans = max(cnt,ans)
            else:
                cnt = 1
        #ans = max(cnt,ans)

        


# [모든 인접한 두 자리 뒤집어보고 찾기]    
# 가로 뒤집기
for i in range(n):
    for j in range(n-1):
        candies[i][j],candies[i][j+1] = candies[i][j+1],candies[i][j]
        search()
        candies[i][j],candies[i][j+1] = candies[i][j+1],candies[i][j]

# 세로 뒤집기
for i in range(n):
    for j in range(n-1):
        candies[j][i],candies[j+1][i] = candies[j+1][i],candies[j][i]
        search()
        candies[j][i],candies[j+1][i] = candies[j+1][i],candies[j][i]

        
print(ans)
-----------------------------------------------------------------------------------------------------------
캠핑

import sys

input = sys.stdin.readline

t= 1
while 1:
  l, p, v = map(int, input().split())

  if l==0 and p ==0 and v ==0:
    break
  
  if  l > v % p:
    c = (v // p) * l + v % p
  else:
    c = (v // p) * l + l
    
  print('Case ' +str(t) +': '+ str(c))
  t+=1
-----------------------------------------------------------------------------------------------------------
부등호
백트래킹 강의라도 봐라 이 시발앝ㄹ타
처음 만들어진 문자열이 최솟값, 마지막에 만들어진 문자열 최댓값.
  
import sys

input = sys.stdin.readline

n = int(input())
a = list(input().split())
visited = [False] * 10

max = ''
min = ''

def possible(i,j,k):
  if k=='<':
    return i<j
  else:
    return i>j

def solve(cnt,s):
  global max, min
  if cnt == n+1: # 길이가 같다면, 추가
    if not len(min): # 최솟값이 없다면 최솟값으로 추가
      min = s
    else:# 있다면 최대값으로 추가
      max = s

  for i in range(10):
    if not visited[i]: #특정 숫자를 아직 방문안하면,
      if cnt ==0 or possible(s[-1], str(i), a[cnt-1]):
        visited[i]= True # 방문하고 
        solve(cnt+1, s+str(i))
        visited[i] = False# 방문 안함
  

solve(0,'')
print(max)
print(min)
-----------------------------------------------------------------------------------------------------------
기타줄
람다 정렬 기억하기!!
아니면 애초에 입력할떄 바로, 정렬시킬수 있다.
  
import sys

input = sys.stdin.readline

n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(m)]

list1 = sorted(a, key=lambda x: x[0])# 0열로 따로 정렬
list2 = sorted(a, key=lambda x: x[1]) # 1열로 따로정렬

s = 0

while 1:
  if n > 6:
    if list1[0][0] < list2[0][1] * 6:
      s += list1[0][0]
      n-=6
    else:
      s += list2[0][1] * 6
      n-=6
  else:
    if list1[0][0] < list2[0][1]*n:
      s += list1[0][0]
      
    else:
      s += list2[0][1] * n
  
    break
    
print(s)
-----------------------------------------------------------------------------------------------------------
맥주마시면서 걸어가기
처음 집과, 페스티벌을 따로 지정해줘도 되고,
한번에 선언했을때, 집인 0에서 출발하고, 마지막은 페스티벌에서 도착한다.

import sys
from collections import deque
input = sys.stdin.readline

def bfs():
    q = deque()
    q.append([home[0], home[1]]) # 처음 집에서 시작
    while q:
        x, y = q.popleft()
        if abs(x - fest[0]) + abs(y - fest[1]) <= 1000: # 축제까지 거리가 1000이하면 happy
            print("happy")
            return
        for i in range(n):
            if not visited[i]: # 아직 방문하지않았다면
                new_x, new_y = conv[i] # 편의점 좌표넣기
                if abs(x - new_x) + abs(y - new_y) <= 1000:
                    q.append([new_x, new_y]) # 점점 축제와 가까워짐
                    visited[i] = 1
    print("sad") # 1000이하가 아니라면 , sac
    return

t = int(input())
for i in range(t):
    n = int(input())
    home = [int(x) for x in input().split()] # 
    conv = []
    for j in range(n):
        x, y = map(int, input().split())
        conv.append([x, y])
    fest = [int(x) for x in input().split()]
    visited = [0 for i in range(n+1)] #home 제외
    bfs()
  -----------------------------------------------------------------------------------------------------------
효율적인 해킹
신뢰하는 관계 => 일방향 간선으로 생각해서 그래프 탐색.
너비우선(BFS)으로 탐색하면서 방문한 정점의 수를 기록.
최대치를 찾아야 하므로 모든 경우를 탐색.
단, Python3 가 아닌 PyPy3로 제출해야 한다.

import sys
input = sys.stdin.readline # 중요!!!!, 입력 속도가 느리면 통과 불가능.
from collections import deque

# 너비 우선 탐색
def bfs(s):
    D = 0
    q = deque()
    q.append(s)
    visit = [0] * (N + 1)
    visit[s] = 1
    while q:
        here = q.popleft()
        D += 1
        for w in G[here]:
            if not visit[w]:
                visit[w] = 1
                q.append(w)
    return D # 방문한 정점의 수 D를 리턴한다.
                
N, M = map(int, input().split())
G = [[] for _ in range(N+1)]
for i in range(M):
    a, b = map(int, input().split())
    G[b].append(a)
mxd = 0
result = []
for i in range(1, N + 1):
    if G[i]:
        tmp = bfs(i) # 리턴값을 받아서 최대값과 비교
        if mxd <= tmp:
            if mxd < tmp:
                result = []
            mxd = tmp
            result.append(i)
print(*result) 
  -----------------------------------------------------------------------------------------------------------  
행렬 
입력할때 걍 개쓰레기같은ㅇ 문제
2차원 배열의 맨 왼쪽 위씩만 비교
  
import sys

input = sys.stdin.readline

count = 0
N,M = map(int,input().split())

change_maps = [list(map(int ,input().strip())) for _ in range(N)] # strip해서 enter 공백 제거해야함
result_maps = [list(map(int ,input().strip())) for _ in range(N)] 

def convert3x3(x,y,arr): # 행렬에서 3*3부분만 바꾸기
    for i in range(x,x+3):
        for j in range(y,y+3):
            change_maps[i][j] = 1 - change_maps[i][j] # 0, 1 스왑

for i in range(0,N-2): # 행렬 맨 왼쪽위만 비교
    for j in range(0,M-2):
        if change_maps[i][j] != result_maps[i][j]: # 배열의 값이 같지 않다
            convert3x3(i,j,change_maps)
            count += 1

# 전체 배열 검사
nonReulst = False
for i in range(0,N):
    for j in range(0,M):
        if change_maps[i][j] != result_maps[i][j]:
            nonReulst = True

if(nonReulst):
    print(-1)
else:
    print(count)  
  -----------------------------------------------------------------------------------------------------------
마인크래프트
고수들 마인드 -> 문제 조건으로 어떻게 풀지 생각함!!!
높이를 0부터 256 하나하나 다해봄.
왜냐면, 256 * 500 * 500 해도 1억이 안넘으니, 충분히 1초 안에 완전탐색으로 풀수있음
단, PyPy3 로 제출해야 정답이 인정된다.
min, max를 따로따로 갯수를 계산해서, 채울수 있다면 마지막에 한번에 시간 계산

from math import inf
import sys

N, M, B = map(int, input().split())
ground = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

tall = 0
ans = inf # 시간초과 방지를 위해 충분히 큰 수로 둠

for i in range(257): # 땅의 높이의 최대는 256이므로 0 ~ 256까지만 탐색
    max = 0
    min = 0
    for j in range(N): # 가로
        for k in range(M): # 세로
            if ground[j][k] < i: # 블럭이 현재 높이 보다 작다면
                min += (i - ground[j][k]) # 현재 높이가 블록 높이보다 높을 때 (min 만큼 인벤토리에서 꺼내서 채워야 함)

            else:
                max += (ground[j][k] - i) # 블록 높이가 현재 높이보다 높을 때 (max 만큼 블록이 제거된 후 인벤토리에 들어감)

    inventory = max + B # 인벤토리에 있는 총 블록수 = 현재 인벤토리에 있는 블록 + max

    if inventory < min: # 전부 채울 수 없으므로 패스
        continue

    # 한번에 제거와, 추가 시간 계산
    time = 2 * max + min # 블록 제거는 2초, 블록 추가는 1초

    # 시간을 진행될수록 최소로 갱신
    if time <= ans: # 높이는 0 ~ 256 까지 오름차순으로 탐색하기 때문에 걸린 시간이 같아도 더 높은 높이가 출력 된다
        ans = time
        tall = i

print(ans, tall) 
  -----------------------------------------------------------------------------------------------------------
문서검색
진짜 ㅈ같은게 input은 \n까지 입력된다. 그래서 삭제해줘야됨.
find는 찾은 문자의 가장 첫번째 인덱스를 알려줌.
count는 이미 체크한 단어는 제외하고 계산함.
ex) ababababa
count(aba) # 2

내 풀이 1. 걍 count 쓰기 - ㅅㅂ 현타옴
import sys

input = sys.stdin.readline

s = input()
s = s[:-1]
r = input()
r = r[:-1]

print(s.count(r)) 

내 풀이 2. 걍 find쓰기
import sys

input = sys.stdin.readline

s = input()
r = input()
r = r[:-1]

c= 0

while 1 :

  if r not in s:
    break
    
  s= s[s.find(r)+len(r):] # find는 찾은 문자의 가장 첫번째 인덱스를 알려줌.
  c += 1

print(c)

다른풀이 3. replace로 단어를 바꿔서 찾아버린다.
import collections
N = input()
M = input()
N=N.replace(M,'@')
#print(N)
a=dict(collections.Counter(list(N)))
if '@' in a:
    print(a['@'])
else:
    print(0)
  -----------------------------------------------------------------------------------------------------------
수리공 항승
예시를 먼저 생각하고, 그림그리면서 해보자!
이 방법은 앞 뒤 간격을 계산할 필요가 없기 때문에 구현하는 데에 있어서 훨씬 간단하다.

import sys

input = sys.stdin.readline

N,L = map(int, input().split())

location = list(map(int,input().split()))
location.sort() # 오름차순은 해줘야함.

start = 0
cnt=0
for loc in location:
    if start<loc:
        #테이프 붙이기
        # start+L-1 까지는 자동으로 수리됨.
        start = loc+L-1
        cnt+=1

print(cnt)
  ----------------------------------------------------------------------------------------------------------
정사각형
n과 m의 작은값으로 시작함
완전탐색이라, 너무 깊게 생각하지말고 그냥 단순하게 전부 하는것도 방법이다.

import sys

input = sys.stdin.readline

n, m = map(int, input().split())

g = [list(map(int ,input().strip())) for _ in range(n)]

k = n if n <= m else m

li = []
for s in reversed(range(k)):
  if len(li) == 1:
      break
  for i in range(n-s):
    if len(li) == 1:
      break
    for j in range(m-s):
      if g[i][j] == g[i][j+s] == g[i+s][j] == g[i+s][j+s]:
        li.append((s+1)**2)
        break
        
print(li)  
  ----------------------------------------------------------------------------------------------------------
그림
bfs할때 맨 처음
1, 1
0 
조건일때 예외 처리를 해줘야한다!

import sys
from collections import deque
input = sys.stdin.readline

n, m = map(int, input().split())

g = [list(map(int ,input().split())) for _ in range(n)]

dx, dy = [-1,1,0,0],[0,0,-1,1]

def bfs(i,j):
  q= deque()
  q.append((i,j))
  
  global c

  while q:
    x, y = q.popleft()

    for i in range(4):
      nx = x + dx[i]
      ny = y + dy[i]

      if 0<= nx < n and 0<= ny < m:
        if g[nx][ny] == 1:
          g[nx][ny] = 0
          c+=1
          q.append((nx,ny))

li = []
for i in range(n):
  for j in range(m):
    if g[i][j] == 1:
      g[i][j] = 0
      c= 1
      bfs(i,j)
      li.append(c)
    else:
      continue

if len(li) == 0:
  print(0)
  print(0)
else:
  print(len(li))
  print(max(li))
  ----------------------------------------------------------------------------------------------------------
숫자야구
한번에 입력을 받는게 아니라, 받을때마다 비교한다.
값을 삭제할때마다, 인덱스를 앞으로 당겨줘야한다.

from itertools import permutations
num = list(permutations((1, 2, 3, 4, 5, 6, 7, 8, 9), 3))  # 서로 다른 수의 세 자리 숫자

t = int(input())
for _ in range(t):
    q, strk, ball = map(int, input().split())
    removed = 0  # 중간의 리스트 길이를 변경하기 때문에 필요한 변수
    q = list(str(q))

    for i in range(len(num)):
        sCnt, bCnt = 0, 0
        i -= removed # 일단 맨처음엔 인덱스가 바뀌지않았다. 다음부터 삭제한 만큼 앞으로 당긴다.
        for j in range(3):
            q[j] = int(q[j])
            if q[j] in num[i]:  # 질문한 숫자의 j번 인덱스의 숫자가 num의 i번째 튜플에 있는가
                if j == num[i].index(q[j]):  # 있고, 위치도 같으면 스트라이크 횟수 ++
                    sCnt += 1
                else:  # 위치는 다르지만 있다면 볼 횟수 ++
                    bCnt += 1
        if sCnt != strk or bCnt != ball:  # 질문을 통해 얻은 답변과, 순열을 통해 얻은 스트라이크, 볼 횟수가 다르면
            num.remove(num[i])  # 후보지에서 제외
            removed += 1  # 달라진 리스트 길이를 위해 removed --
print(len(num)) # 다 지우고 남은 선택지 갯수
  ----------------------------------------------------------------------------------------------------------
특정 거리의 도시찾기
bfs는 모든 노드의 거리가 동일할떄 사용
아 bfs 시발 좀만 더 단순하게 생각하고, 첫 번쨰 도시일때 무조건 예외 체크!!!! 시밞 명윤아ㅏ
import sys
from collections import deque

input = sys.stdin.readline

# N 도시 수, M 도로 수, K 거리 정보 X 출발 도시
N, M, K, X = map(int, input().split(' '))
graph = [[] for _ in range(N+1)]

for _ in range(M):
  a, b =  map(int, input().split(' '))  
  graph[a].append(b)

distance = [0] *(N+1)
distance[X] = 0

# BFS 부분
q = deque([X])
while q:
  now = q.popleft()

  for next in graph[now]:
    if distance[next] == 0:
      distance[next] = distance[now]+1
      q.append(next)

# K값이 distance에 있다면 i값출력 없다면 -1 출력
if K in distance:
  for i in range(1, N+1):
    if distance[i] == K:
      if i == 1:
        print(-1)
      else:
        print(i)
else:
  print(-1)


내 풀이 반례좀 알려줘라 제발
import sys
from collections import deque

input = sys.stdin.readline

n, m, k, x = map(int, input().split())

li = []

def bfs(start):
  q = deque()
  q.append(start)

  while q:
    s = q.popleft()

    for i in g[s]:

      if visited[i]:
        continue
        
      visited[i] = visited[s] +1

      if visited[i] != k:
         q.append(i)
      else:
          li.append(i)
          continue

  if len(li) ==0 or start in li:
      print(-1)
  else: 
    for i in li:
      print(i)

g = [[] for _ in range(n+1)]

visited = [0] * (n+1)

for i in range(m):
  a, b = map(int, input().split())
  g[a].append(b)

bfs(x)
  ----------------------------------------------------------------------------------------------------------
점프점프
dp = [-1] * n # 가장 마지막에 없을 경우는 -1 출력위해서
dp[start] = 0 # 처음시작하는 부분만 0으로 시작해서 거리 측정
최소문제이므로, dfs로 하면 시간초과
탐색이 의외로 단순하게 풀린다!! 

import sys
sys.setrecursionlimit(1000000)

input = sys.stdin.readline

n = int(input())
lst = list(map(int, input().split()))

dp = [-1] * n # 가장 마지막에 없을 경우는 -1 출력위해서

def bfs(start):
    q = []
    q.append(start)
    dp[start] = 0 # 처음시작하는 부분만 0으로 시작해서 거리 측정
    while q:
        now = q.popleft()
        jump = lst[now]
        for i in range(jump, 0, -1): # 큰 범위부터 점프
            if now + i < n and dp[now + i] == -1: # 마지막 지점까지의 범위고, 아직 방문하지안했으면,
                dp[now + i] = dp[now] + 1 # 이전에 온 거리만큼 1 점프
                q.append(now + i) # 큐에 넣기

bfs(0)
print(dp[-1]) # 마지막 지점의 거리 출력. 없으면 그대로 -1 임

다른풀이 dp
import sys

n = int(sys.stdin.readline())
a = list(map(int, sys.stdin.readline().split()))
dp = [sys.maxsize] * (n + 1)
dp[0] = 0

# 반복문을 통해 점프를 확인한다.
for i in range(n):
    # 점프로 갈 수 있는 칸을 확인
    for j in range(a[i]):
        if i + j + 1 < len(dp):
            # 점프한 칸에 점프 횟수에 값을 최솟값으로 초기화
            dp[i + j + 1] = min(dp[i + j + 1], dp[i] + 1)

# 마지막 칸에 점프 횟수로 바꼈다면 점프 횟수를 출력
if dp[n - 1] < sys.maxsize:
    print(dp[n - 1])
else:
    print(-1)
----------------------------------------------------------------------------------------------------------
병든 나이트
조건이 시발 무슨 20억이상인 자연수여;;
그럼 bfs는 아니고 dfs도 아니고 그리디임.
----------------------------------------------------------------------------------------------------------
음식물 피하기 
기본적인 dfs, bfs 문제
방문해준건 0으로 해주는게 중요!
---------------------------------------------------------------------------------------------------------
팰린드롬 만들기
비슷하게 생각했엇는데 아쉽..
앞만 만들어놓고, 리버스 시켜 뒤에 덧붙혀준다고 생각하자!

 = list(input())
alphabet = [chr(i) for i in range(65, 91)]
alphabet_cnt = [0 for i in range(len(alphabet))]

odd_cnt = 0
odd_chr = ""
for i in range(len(alphabet)):
    alphabet_cnt[i] = s.count(alphabet[i])
    if alphabet_cnt[i] % 2 == 1:
        odd_cnt += 1
        odd_chr = alphabet[i]

s = sorted(list(set(s)))
ans_front = []
for j in s:
    if odd_cnt >= 2:
        print("I'm Sorry Hansoo")
        quit()
    ans_front.append(j*(alphabet_cnt[alphabet.index(j)] // 2))

ans_back = list(reversed(ans_front))

if odd_cnt == 1:
    ans_front.append(odd_chr)
ans = ans_front + ans_back

print(*ans, sep="")
---------------------------------------------------------------------------------------------------------
연속부분 최대곱
전형적인 현재와, 이전에 계산한 값을 비교하는 DP문제
각 값을 기존 배열에 넣고, 최대값을 산출
print('{:.3f}'.format(max(f)))# 소수점 셋째까지 반올림해서 나옴.

import sys

input = sys.stdin.readline

n = int(input())
f = [float(input()) for _ in range(n)]


for i in range(1, n):
  f[i] = max(f[i]*f[i-1], f[i])

print('{:.3f}'.format(max(f)))
---------------------------------------------------------------------------------------------------------
카드합체 놀이
반면 우선순위 큐를 사용하면, 값이 바뀐 카드 2개를 다시 우선순위 큐 자료구조 안에 삽입하기만 하면 된다. 
heap에서 삽입 연산의 시간 복잡도는 O(logn)으로, 훨씬 효율적이다.

내풀이
import sys

input = sys.stdin.readline

n, m = map(int, input().split())

l = list(map(int, input().split()))

for i in range(m):
  l = sorted(l)
  k = l[0] +l[1]
  l[0] = k
  l[1] = k

print(sum(l))

힙 이용
from sys import stdin
import heapq

n, m = map(int, stdin.readline().split())

cards = [int(x) for x in stdin.readline().split()]
# cards 리스트를 heap으로 변환
heapq.heapify(cards)

for _ in range(m):
    card1 = heapq.heappop(cards)
    card2 = heapq.heappop(cards)

    heapq.heappush(cards, card1 + card2)
    heapq.heappush(cards, card1 + card2)

print(sum(cards))
---------------------------------------------------------------------------------------------------------
친구
그냥 ㅈㄹ 하지말고 bfs로 풀자 
플로이드 워셜
for문 중첩 3번에
if 같은경우 continue
if [i][j] == 'Y' or ([i][k] == 'Y' and [k][j] == 'Y' )

import sys
from collections import deque

# bfs 탐색
def bfs(v):
    visited = [False] * n
    queue = deque([[v, 0]]) # 사람의 번호와 친구와의 관계
    visited[v] = True
    cnt = 0
    while queue:

        a, b = queue.popleft()

        # 친구와의 관계가 2이상이면 생각하지 않는다.
        if b >= 2:
            continue

        # 반복문을 통해 탐색하지 않은 사람이고 그 사람이 친구가 있는지 확인
        for i in range(n):
            if not visited[i] and graph[a][i] == "Y":
                cnt += 1
                visited[i] = True
                queue.append([i, b + 1])

    return cnt

n = int(sys.stdin.readline())
graph = [list(map(str, sys.stdin.readline().strip())) for _ in range(n)]

res = 0
# 각 사람마다 친구의 2-친구의 수를 구하고 제일 유명한 사람을 출력한다.
for i in range(n):
    res = max(res, bfs(i))

print(res)
---------------------------------------------------------------------------------------------------------
모의고사
하 ㅅㅂ 명윤아 한번에 다 하려고 개ㅈㄹ하지말고 그냥 순서대로 변수 하나씩 짜라..
완전탐색같은거 제발 차근차근해라.. 하 개 ㅅㅂ
규칙발견.

----------------------------------------------------------------------------------------------------
소수찾기
참고
per += list(permutations(nums, i))        # 이게 그냥 []배열에 이어서 추가되는거임!!

어떤 수의 약수는 항상 짝이 존재한다. 
짝을 이루는 두 수가 다른 수라면 하나는 크고 하나는 작을 것이다. (당연한 말)
약수의 짝 중 작은 수는 제곱근보다 크지 않을 것이다. 
그렇기 때문에 range 의 끝 범위를 total ** 0.5 까지 하면 된다.


from itertools import permutations

def solution(numbers):
    answer = []                                   
    nums = [n for n in numbers]                   # numbers를 하나씩 자른 것
    per = []                                      
    for i in range(1, len(numbers)+1):            # numbers의 각 숫자들을 순열로 모든 경우 만들기
        per += list(permutations(nums, i))        # 이게 그냥 []배열에 이어서 추가되는거임!!
    new_nums = [int(("").join(p)) for p in per]   # 각 순열조합을 하나의 int형 숫자로 변환

    for n in new_nums:                            # 모든 int형 숫자에 대해 소수인지 판별
        if n < 2:                                 # 2보다 작은 1,0의 경우 소수 아님
            continue
        check = True            
        for i in range(2,int(n**0.5) + 1):        # n의 제곱근 보다 작은 숫자까지만 나눗셈
            if n % i == 0:                        # 하나라도 나눠떨어진다면 소수 아님!
                check = False
                break
        if check:
            answer.append(n)                      # 소수일경우 answer 배열에 추가

    return len(set(answer))                       # set을 통해 중복 제거 후 반환
-----------------------------------------------------------------------------------------------------
카펫
당연하게 적으면 됐을것을... ㅅㅂ
수학 수식도 이용한다. 입출력 예를 자세히보고 규칙을 파악하자.

def solution(brown, yellow):
    answer = []
    total = brown + yellow                  # a * b = total
    for b in range(1,total+1):
        if total % b == 0:            # total / b = a
            a = total // b
            if a >= b:                      # a >= b
                if 2*a + 2*b == brown + 4:  # 수학 수식
                    return [a,b]
            
    return answer
-----------------------------------------------------------------------------------------------------
타겟 넘버
확실히 dfs, bfs 논리적으로 생각좀 하면서 풀자.. ㅅㅂ..

from collections import deque

def solution(numbers, target):
    answer = 0
    
    q =deque()
    q.append((0,numbers[0]))
    q.append((0,-numbers[0]))
    
    c = 0
    
    while q:
        i, a = q.popleft()
          
        if i == len(numbers) -1:
            if a == target:
                c += 1      
        else:       
            q.append((i+1, a + numbers[i+1]))
            q.append((i+1, a - numbers[i+1]))
                
    return c

-----------------------------------------------------------------------------------------------------
네트워크
그래프 노드를 n개까지 범위로 반복문 돌려야했다..

dfs
def solution(n, computers):            
    
    def DFS(i):
        visited[i] = 1
        for a in range(n):
            if computers[i][a] and not visited[a]:
                DFS(a)      
                
    answer = 0
    visited = [0 for i in range(len(computers))]
    for i in range(n):
        if not visited[i]:
            DFS(i)
            answer += 1
        
    return answer

bfs
from collections import deque

def solution(n, computers):            
    
    def BFS(i):
        q = deque()
        q.append(i)
        while q:
            i = q.popleft()
            visited[i] = 1
            for a in range(n):
                if computers[i][a] and not visited[a]:
                     q.append(a)
                
    answer = 0
    visited = [0 for i in range(len(computers))]
    for i in range(n):
        if not visited[i]:
            BFS(i)
            answer += 1
        
    return answer
--------------------------------------------------------------------------------------------------------------
설탕배달
dp또는 그리디
생각보다 되게 간단하게 풀릴 수도 있다.
이미 한번 나온수면, 방문한거로 체크!!

내 풀이 - dp
import sys
from collections import deque

input = sys.stdin.readline
n = int(input())

visit = [0] * n
s = 0

q = deque()
c = 0
q.append((s, c))

result = []
while q:
  x, y = q.popleft()
  if x ==n:
    print(y)
    break

  if x < n and visit[x] ==0:
    y+=1
    visit[x] = 1
    q.append((x+5, y))
    q.append((x+3, y))
else:
  print(-1)

다른 풀이 - 그리디
sugar = int(input())

bag = 0
while sugar >= 0 :
    if sugar % 5 == 0 :  # 5의 배수이면
        bag += (sugar // 5)  # 5로 나눈 몫을 구해야 정수가 됨
        print(bag)
        break
    sugar -= 3  
    bag += 1  # 5의 배수가 될 때까지 설탕-3, 봉지+1
else :
    print(-1)
--------------------------------------------------------------------------------------------------------------
1로 만들기
dp는 역시 무조건 dfs, bfs는 아니다!
메모이제이션으로 이전값만 저장한다는 개념 가져가자!

n = int(input())

dp = [0] * (n+1)

for i in range(2, n+1):
    dp[i] = dp[i-1] + 1 # 무조건 1은 빼야하므로 횟수추가

    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2]+1) # 2로 나눠지면, 기존횟수랑 나누어떨어지는 횟수 중 작은값
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1) # 3으로 나눠지면, 기존횟수랑 나누어떨어지는 횟수 중 작은값

print(dp[n])
--------------------------------------------------------------------------------------------------------------
피보나치 함수
# 동적 계획법 (Dynamic Programming)
 - Recursive + Memorization
 - 순서를 직접 써서, 점화식 찾자!
   -> 작은 문제의 해를 테이블에 저장한 뒤, 나중에 읽어서 사용
 - 상향식 (작은 -> 큰) <-> 하향식 (분할 정복)
 - 대표적인 예로 피보나치 수열이 있다.

# 일반 풀이
def fib(N):
    zeros=[1,0,1] # 예시 3 이외부터 시작
    ones=[0,1,1]
    if N >= 3:
        for i in range(2,N):
            zeros.append(zeros[i-1] + zeros[i]) # 0의 피보나치 순서를 추가
            ones.append(ones[i-1] + ones[i]) # 1의 피보나치 순서를 추가
    print(f"{zeros[N]} {ones[N]}") # 출력
 
T = int(input())
for _ in range(T):
    N = int(input())
    fib(N)

# 숏코딩 풀이 - 와 이건 사람이 아니네 생각하는게;
T = int(input())
for _ in range(T):
    N = int(input())
    zero,one=1,0 # zero: 0개수, one: 1개수
    for i in range(N):
        zero,one = one,zero+one # zero와 one에 그 자체로 피보나치적용
    print(zero,one)
--------------------------------------------------------------------------------------------------------------
토마토
이 문제의 핵심은 여러 곳에서 시작하는 bfs였음!!
그래서 모든 좌표에서 1일때 큐에 박고시작함!!
matrix[nx][ny] = matrix[x][y] + 1 # 최소 횟수 전염되는거 기억!

import sys

input = sys.stdin.readline

from collections import deque

m, n = map(int, input().split())
matrix = [list(map(int, input().split())) for _ in range(n)]
queue = deque([])
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]
res = 0

for i in range(n):
    for j in range(m):
        if matrix[i][j] == 1:
            queue.append([i, j]) # 기존과 다르게 일단 박고 시작함.

def bfs():
    while queue:
        x, y = queue.popleft()
        for i in range(4):
            nx, ny = dx[i] + x, dy[i] + y
            if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 0:
                matrix[nx][ny] = matrix[x][y] + 1 # 최소 횟수 전염되는거 기억!
                queue.append([nx, ny])

bfs() # 박은 큐들을 시작
for i in matrix:
    for j in i:
        if j == 0:
            print(-1)
            exit(0) # 두개 반복문 바로 탈출 = 종료
    res = max(res, max(i)) # 모든 배열 중 가장 최댓값
print(res - 1)
--------------------------------------------------------------------------------------------------------------
계단오르기
마지막계단을 무조건 밟아야해서, 올라 가는거말고, 아래에서부터 올라온다고 생각하기!
이런 사고의 전환을 길러야한다!

import sys

input = sys.stdin.readline

N = int(input())

stair = [0]
for _ in range(N):
    stair.append(int(input()))

if N == 1: 
    print(stair[1])
else:
    dp = [0] * (N+1) 
    dp[1] = stair[1] #첫번째 계단
    dp[2] = stair[1] + stair[2] #두번째 계단

    for i in range(3, N+1): # 세번째부터 지정
        # 한칸 이전에서 올라올때는 그 칸에서 아래아래까지 더해줌, 두칸 이전에서는 상관없음
        dp[i] = max(dp[i-3]+stair[i-1]+stair[i], dp[i-2]+stair[i])  

    print(dp[N])
--------------------------------------------------------------------------------------------------------------
2×n 타일링
dp는 점화식이면 끝이다!
뭘 어쩔지 모를땐 늘 그렇듯 그림을 그리자!

import sys
input = sys.stdin.readline

n = int(input())
dy = [0]*(n+1)

if n == 3:
    print(n)

else:
    dy[1] = 1
    dy[2] = 2

    for i in range(3,n+1):
        dy[i] = dy[i-1]+dy[i-2] # 점화식으로 그려서, 세로로 하나 세워졌을떄와 가로로 두개 엎어져있을때 나열을 더해준다.

    print(dy[n]%10007)
--------------------------------------------------------------------------------------------------------------
가장 긴 증가하는 부분 수열

import sys

input = sys.stdin.readline

n = int(input())  # 수열의 길이
array = list(map(int, input().split()))  # 주어진 수열

# 처음에는 전부 각각 본인만 취급, 1로 초기화
dp = [1] * n

for i in range(1, n): # 두번째원소부터 비교
    for j in range(0, i): # 첫원소부터 i이전까지 비교군
        if array[j] < array[i]: # 현재원소보다 작은게있다면
            dp[i] = max(dp[i], dp[j] + 1) # 가장 큰 횟수 + 1 값이 현재수보다 작은 갯수가됨.

# 각 원소는 본인보다 작은 증가수열값, 그 중 최대값 출력
result = max(dp)
print(result)
--------------------------------------------------------------------------------------------------------------
쉬운 계단수
dp는 역시 제발 일단 모르겠으며어어어어언~~~ 일단 규칙이나 점화식을 찾아봐 제에에발!!!!!!!!!!!!!!!!!!!!
[아이디어]
1) 다루는 수가 꽤나 커서 직접 모든 자리수를 탐색할 수는 없다.
2) 한 자리일 때부터, 자리 수가 늘어날 때마다 이전 자리 수에서의 계단 수를 기준으로 몇 개가 만들어지는지 구한다.

import sys
input = sys.stdin.readline

n = int(input()) 

dp = [[0 for i in range(10)] for j in range(101)] # 최대

for i in range(1, 10): # 자리가 1자리면, 처음은 말고 뒤에 1로채움
    dp[1][i] = 1
for i in range(2, n + 1): # 자리가 2번째부터 시작
    for j in range(10): 
        if j == 0: # 끝자리가 0인거
            dp[i][j] = dp[i - 1][1] # 그대로내려오기
        elif j == 9:# 끝자리가 9인거
            dp[i][j] = dp[i - 1][8] # 9는 끝자리라 대각선 한개만 그래서 8번째
        else: # 점화식 비교하면 대각선 양쪽 방향 더한거
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
print(sum(dp[n]) % 1000000000)
--------------------------------------------------------------------------------------------------------------
연속합
아니 이렇게 간단하게 나오는게 말이돼?? 하 개현타오네,,,
일단 빡구현이 아니면, 문제상 코드가 길수가없는듯,,,
"주어진 배열에 있어서 최대(최선)의 선택을 해야하니깐... max함수를 이용한 DP문제가 아닐까?
DP 문제는 항상 규칙을 찾고 수열이 주어졌을 때,
DP 배열을 구성할 똑같은 크기의 수열이 필요하단 사실이 중요함!!!

import sys
input = sys.stdin.readline

n = int(input())

arr = list(map(int, input().split()))
dp = [0] * len(arr)
dp[0] = arr[0]

for i in range(1, len(arr)):
    dp[i] = max(arr[i], dp[i-1] + arr[i]) # 더하다 음수가 나오면, 그냥 해당 원소로 교체

print(max(dp))
--------------------------------------------------------------------------------------------------------------
포도주 시식
역시 순서대로 규칙 찾아서 점화식 찾는게 근본이다,, 근데 그게 어렵지,,,시바
계단오르기 문제같이, 앞에서 순서대로 마셔가는게아니라, 내 기준 이전에 와인을 몇개마실지 정해야한다.
이런 사고의 전환이 언제 길러질까,, 답답하다 진짜 명윤아,,

import sys
input = sys.stdin.readline

n = int(input())
wines = [0] + [int(input()) for _ in range(n)] + [0]
dp = [0] * (n+2)
dp[1] = wines[1]
dp[2] = dp[1] + wines[2]

for i in range(3, n+1):
    dp[i] = max(dp[i-3]+wines[i-1]+wines[i], dp[i-2]+wines[i], dp[i-1])
print(dp[n])
--------------------------------------------------------------------------------------------------------------
벽 부수고 이동하기
와 벽부수고 안부수고를 visit 3차원 행렬로 표시함,, 대단,,
visit = [[[0]*2 for _ in range(m)] for _ in range(n)] # 3차원 visit 스킬
웬만하면 visit 이용하는습관 들이자,, 다 쓰는 이유가 있으니깐,, ㅇㅋ?

N과 M의 범위가 1 이상 1000 이하이기 때문에 브루트포스 방식도 불가능했고,
최단거리를 만들기 위한 벽을 찾는 방법을 찾는 것도 잘 안떠오름
모든 작업을 한 번의 BFS 탐색을 통해 처리해야했기 때문에, 최적의 벽을 '탐색'하는 것보다는 '기록'하는 방식이 필요했드아,,

import sys
from collections import deque

input = sys.stdin.readline

n, m = map(int, input().split())
graph = []

# 3차원 행렬을 통해 벽의 파괴를 파악함. visited[x][y][0]은 벽 파괴 가능. [x][y][1]은 불가능.
visited = [[[0] * 2 for _ in range(m)] for _ in range(n)]
visited[0][0][0] = 1

for i in range(n):
    graph.append(list(map(int, input())))

# 상하좌우
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

def bfs(x, y, z):
    queue = deque()
    queue.append((x, y, z))

    while queue:
        a, b, c = queue.popleft()
        # 끝 점에 도달하면 이동 횟수를 출력
        if a == n - 1 and b == m - 1:
            return visited[a][b][c]
        for i in range(4):
            nx = a + dx[i]
            ny = b + dy[i]
            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue
            # 다음 이동할 곳이 벽이고, 벽파괴기회를 사용하지 않은 경우
            if graph[nx][ny] == 1 and c == 0 :
                visited[nx][ny][1] = visited[a][b][0] + 1
                queue.append((nx, ny, 1))
            # 다음 이동할 곳이 벽이 아니고, 아직 한 번도 방문하지 않은 곳이면
            elif graph[nx][ny] == 0 and visited[nx][ny][c] == 0:
                visited[nx][ny][c] = visited[a][b][c] + 1
                queue.append((nx, ny, c))
    return -1

print(bfs(0, 0, 0))
--------------------------------------------------------------------------------------------------------------
1, 2, 3 더하기
조건 찾느라 뻘짓하다가, 수가 작고, 합 갯수 규칙찾는거라 DP인걸 깨달음,, 답없는 이명윤
정말 DP스럽게 접근해야 하는 문제, 점화식을 잘 세우는게 문제의 전부다.
걍 DP는 규칙 그리는게 짱이다! 니가 짱먹어라 짱~

import sys
from collections import deque

input = sys.stdin.readline

n = int(input())
t = [int(input()) for _ in range(n)]
dp = [1, 2, 4, 0 , 0, 0, 0, 0, 0, 0]

for i in range(3,10):
  dp[i] = dp[i-3]+ dp[i-2] +dp[i-1]

for i in range(n):
  print(dp[t[i]-1])
--------------------------------------------------------------------------------------------------------------
RGB거리
좀 dp 문제가 코테에서 엄청 어렵게 안나온다고 무지성 믿음을 가지고,
제발제발제발제발제발제발 dp[n] = 대충 dp[n-1]로 간단하게 짠다고 생각하자 제발제발!!!!!!!!!!

import sys

input = sys.stdin.readline

n = int(input())
p = []

for i in range(n):
    p.append(list(map(int, input().split())))
for i in range(1, n): # 하나씩 이전 칸의 옆가지 색 최솟값 + 현재칸 색깔
    p[i][0] = min(p[i - 1][1], p[i - 1][2]) + p[i][0]
    p[i][1] = min(p[i - 1][0], p[i - 1][2]) + p[i][1]
    p[i][2] = min(p[i - 1][0], p[i - 1][1]) + p[i][2]
  
print(min(p[n - 1][0], p[n - 1][1], p[n - 1][2]))
--------------------------------------------------------------------------------------------------------------
알파벳
다시 set()에서 없애는 방법이 중요하다. 
혹여나 최대 칸 수가 아닌 경우 돌아가기 위해서이다. 
이 과정에서 백트래킹 과정이다. 아무튼 count를 최댓값으로 갱신해서 마지막에 출력하면 된다.

1. bfs를 duque가 아닌 set을 이용한 풀이
속도 deque < set 임.. set O(1) deque O(n)
import sys

# 좌, 하, 우, 상
dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]

def BFS(x, y):
    global answer
    q = set([(x, y, board[x][y])])

    while q:
        x, y, ans = q.pop()

        # 좌우상하 갈 수 있는지 살펴본다
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            # index 벗어나지 않는지 체크하고, 새로운 칸이 중복되는 알파벳인지 체크한다
            if ((0 <= nx < R) and (0 <= ny < C)) and (board[nx][ny] not in ans):
                q.add((nx,ny,ans + board[nx][ny]))
                answer = max(answer, len(ans)+1)

R, C = map(int, sys.stdin.readline().split())
board = [list(sys.stdin.readline().strip()) for _ in range(R)]

answer = 1
BFS(0, 0)
print(answer)


2. dfs set을 이용한 백트래킹 pypy제출 풀이
import sys

# 좌, 하, 우, 상
dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]

def DFS(x, y, ans):
    global answer

    answer = max(ans, answer) # 최대값 갱신

    # 좌우상화 다 확인한다
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        # index 벗어나지 않는지 체크하고, 새로운 칸이 중복되는 알파벳인지 체크한다
        if ((0 <= nx < R) and (0 <= ny < C)) and (board[nx][ny] not in passed):
            passed.append(board[nx][ny]) # 제일 중요한 백트래킹 부분~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            DFS(nx, ny, ans+1) # 다음 count로 보내버리고
            passed.remove(board[nx][ny]) # 이제 다른 경우일때 최대 구하기위해, 현재 추가한건 제거

R, C = map(int, sys.stdin.readline().split())
board = [list(sys.stdin.readline().strip()) for _ in range(R)]
passed = set() # 중복은 편하게 처리, 시간도 빠름

answer = 1
DFS(0, 0, answer)
print(answer)
--------------------------------------------------------------------------------------------------------------
이친수
진짜 드디어 극적으로 dp문제 맞췄다~~~~~~~~~~~~~!!!!!!!!!!!!!!!!!!!!!!!!!!!
역시 dp라고 확신이 들면, 뒤에서부터 규칙을 찾으며 그린게 신의 한수였다.
단, 1일때 처리를 안해주면, 런타임 에러가 난다,,

import sys

input = sys.stdin.readline

n = int(input())

if n == 1: # 이거 안하면 런타임 에러
  print(1)
  exit()

d = [0] * n

d[0] = 1
d[1] = 1

for i in range(2, n):
  d[i] = d[i-1] + d[i-2] # 알고보니 피보나치였음
  
print(d[n-1])
--------------------------------------------------------------------------------------------------------------
리모컨
하, 50만개라 브루트포스 아닐줄 알았는데 맞네,, 좀 더 신중히 생각하자.,
채널은 무한대라고 힌트를 줬으니, range는 범위의 2배인 1,000,000까지로 설정.
왜냐면 50만보다 작은경우에서 접근할수도있고, 더 큰 경우에서 접근할수도 있으므로.

import sys
input = sys.stdin.readline

target = int(input())
n = int(input())
broken = list(map(int, input().split()))

# 현재 채널에서 + 혹은 -만 사용하여 이동하는 경우
min_count = abs(100 - target)

for nums in range(1000001):
    nums = str(nums)
    
    for j in range(len(nums)):
        # 각 숫자가 고장났는지 확인 후, 고장 났으면 break
        if int(nums[j]) in broken:
            break

        # 고장난 숫자 없이 마지막 자리까지 왔다면 min_count 비교 후 업데이트
        elif j == len(nums) - 1:
            min_count = min(min_count, abs(int(nums) - target) + len(nums))

print(min_count)
--------------------------------------------------------------------------------------------------------------
평범한 배낭
이런 문제는 유명한 냅색 알고리즘, 간단하게 말하면, 한 도둑이 훔치는 배낭의 무게 최댓값이 정해져 있고, 
일정 가치와 무게가 있는 짐들을 배낭에 넣을 때, 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제이다.

냅색 알고리즘은 담을 수 있는 물건이 나눌 수 있냐 없냐에 따라 나눈다.
1. 담을 수 있는 물건이 나누어 질 때(설탕 몇 g 등): 분할가능 배낭문제(Fractional Knapsack Problem)
2. 담을 수 있는 물건이 나누어 질 수 없을 때(담는다 or 안담는다): 0-1 배낭문제(0-1Knapsack Problem)
해당 문제는 0-1 배낭문제의 경우다.

표에 무게를 각 시도마다 기록하는 방법을 이용한다.
만약 무게가 작다면, 저장된 가치와 지금 무게의 가치를 비교해 저장시켜준다.
이해안되면, https://codingmovie.tistory.com/48 참고.

import sys

input = sys.stdin.readline

N,K = map(int,input().split())
items = []
for _ in range(N):
    w,v = map(int,input().split())
    items.append((w,v))
  
dp = [0 for _ in range(K+1)]

for item in items:
    w,v = item
    for i in range(K,w-1,-1):
        dp[i] = max(dp[i],dp[i-w]+v)
      
print(dp[-1])
--------------------------------------------------------------------------------------------------------------
파도반 수열
그냥 조건보고 이건 dp다 싶어서
원소 규칙보고, 점화식 세웠다.

import sys

input = sys.stdin.readline

N = int(input())
arr = [int(input()) for _ in range(N)]
seq = [1, 1, 1, 2, 2]

for i in range(5, max(arr)):
    seq.append(seq[i-1]+seq[i-5])

for i in arr:
    print(seq[i-1])
--------------------------------------------------------------------------------------------------------------
01타일
이것도 조건보니 그냥 dp같아서 무지성으로 규칙찾다가, 수를 틀렸다,,
다시 세보니, 뭔가 피보나치 삘이 와서 했는데... 정답. 키야~
이 문제와 같이 "~로 나눈 나머지를 출력한다"는 문제는 거의 대부분 전체 답을 먼저 구하고
마지막에 나머지 연산을 한 번 하라는 것이 아니라, 연산 과정에서 모듈로의 성질을 이용하여
수를 계속 작게 유지할 수 있도록 배려를 해줌.
안 그러면 수가 너무 커져서 계산시간도 오래 걸릴 뿐만 아니라, 파이썬처럼 bigint를 지원하지 않는 
언어에서는 구현하는 것 자체가 매우 까다롭다.

풀긴했지만 풀이 참고
문제의 상황에서 맨 앞에 올 수 있는 타일은 2가지 뿐, 00 타일과 1 타일.
(1). 00 타일이 올 경우 00..으로 시작
(2). 1 타일이 올 경우 1...로 시작
이때 '길이가 N인 이진 수열의 개수'를 f(N)이라고 정의
그러면 경우 (1)의 가짓수는 f(N-2)가 되고 경우 (2)의 가짓수는 f(N-1)이 됨
따라서 전체 경우의 수 f(N) 은 경우 (1) 과 (2)의 가짓수의 합인 f(N) = f(N-1) + f(N-2)가 됨

import sys

input = sys.stdin.readline

n = int(input())

d = [0] * (n+1)

d[0] = 1
d[1] = 1

for i in range(2,n+1):
  d[i] = (d[i-1] +d[i-2])%15746 # 마지막 출력할때말고, 계산할때 바로바로 나누는 습관 들이자!!!

print(d[n]) 
--------------------------------------------------------------------------------------------------------------
이분 그래프
이분 그래프는 서로 인접한 노드끼리 색깔이 다른 그래프임
포인트는 서로 같은 색깔끼리 같은 그룹으로 지정해주면 됨!
또 아예 안 이어진 그래프도 존재할 수 있으니, 애초에 모든 점을 다 탐색해봐야 함.
뽀인트!!!!! visited[w] = -1 * visited[v] # 이렇게 양수, 음수로 현재 노드와 다른 그룹 지정!!

import collections
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

for _ in range(int(input())):
    V, E = map(int, input().split())
    graph = [[] for i in range(V+1)] # 빈 그래프 생성
    visited = [0] * (V+1) # 방문한 정점 체크

    for _ in range(E):
        a,b = map(int, input().split())
        graph[a].append(b) # 무방향 그래프
        graph[b].append(a) # 무방향 그래프

    q = collections.deque()
    group = 1
    bipatite = True
    for i in range(1, V+1):
        if visited[i] == 0: # 방문하지 않은 정점이면 bfs 수행
            q.append(i)
            visited[i] = group
            while q:
                v = q.popleft()
                for w in graph[v]:
                    if visited[w] == 0: # 방문하지 않은 정점이면 큐에 삽입
                        q.append(w)
                        visited[w] = -1 * visited[v] # 현재 노드와 다른 그룹 지정
                    elif visited[v] == visited[w]: # 이미 방문한 경우, 동일한 그룹에 속하면 False
                        bipatite = False

    print('YES' if bipatite else 'NO')
--------------------------------------------------------------------------------------------------------------
정수 삼각형
더해가면서 합이 최대가 되는 경우는 직관적으로 dp로도 생각할수 있음!!!!!!
dp도 2차원 배열로 풀기도 한다는 걸 알자~~~~~~
맨 밑의 자리 즉, 4 5 2 6 5 각 자리에 올 수 있는 가장 큰 값을 구하고, 
그 값들 중에서 가장 큰 값을 출력해줌.

n = int(input())
t = []
for i in range(n):
    t.append(list(map(int, input().split())))
k = 2
for i in range(1, n):
    for j in range(k):
        if j == 0: # 줄의 맨 처음
            t[i][j] = t[i][j] + t[i - 1][j]
        elif i == j: # 맨 끝
            t[i][j] = t[i][j] + t[i - 1][j - 1]
        else: # 양 쪽 대각선 비교
            t[i][j] = max(t[i - 1][j - 1], t[i - 1][j]) + t[i][j]
    k += 1
print(max(t[n - 1]))
--------------------------------------------------------------------------------------------------------------0
퇴사
역방향으로 해야한다는 점이 핵심!
역방향도 역방향인데, 그냥 생각하는거 자체가 개어려웠음 하,,,
설명을 봐도 뭔 소린지 모르겟는 문제는 거의 처음이었다,, 그 정도 문제는 아닌거같은데,,
하루하루 예시 다 적어가면서 한후에나 겨우 이해라도 됨.. 

import sys
readline = sys.stdin.readline

N = int(readline())
T, P = [], []
for _ in range(N):
    t, p = map(int, readline().split())
    T.append(t) # 일과 수입을 따로따로
    P.append(p) # 수입

d = [0] * (N+1)

for i in range(N - 1, -1, -1): # 제일 중요한 역방향으로~~~~~~~~~~~~~~~~~~~~~~~~
    # i일에 상담을 하는 것이 퇴사일을 넘기면 상담을 하지 않음
    if i + T[i] > N:
        d[i] = d[i+1] # 이날 상담안해도 넣어줘야한다.
    else:
        # i일에 상담을 하는 전제, 이날 상담을 안하고 다음날부터 한다는 전제 중 큰 것을 선택
        d[i] = max(d[i+1], P[i] + d[i + T[i]])

print(d[0]) 
--------------------------------------------------------------------------------------------------------------
스타트와 링크
조건보니 완탐이었고, 더 빠르게 해결할 수 있는 백트래킹이었음.

1. 조합으로 푸는법
순서쌍 구별하는 방법 2가지
1. 조합순서상 예를 들어 처음 1,2번을 뽑으면 무조건 마지막은 3,4번을 뽑은 여집합임, 즉 t[i], t[-i-1]임
2. n명의 인원 중에서 n//2의 인원을 뽑고 나머지 인원은 set으로 차집합시켜서 빼줌.

import sys
input = sys.stdin.readline

from itertools import combinations

n = int(input())
array = [i for i in range(n)]
matrix = [list(map(int, input().split())) for _ in range(n)]

result = int(1e9)

for r1 in combinations(array, n//2):
    start, link = 0, 0
    r2 = list(set(array) - set(r1))
    for r in combinations(r1, 2):
        start += matrix[r[0]][r[1]]
        start += matrix[r[1]][r[0]]
    for r in combinations(r2, 2):
        link += matrix[r[0]][r[1]]
        link += matrix[r[1]][r[0]]
    result = min(result, abs(start-link))
  
print(result)


2. 백트래킹으로 푸는법
백트래킹을 풀때는 주의점 2개
- 재귀함수 중단 조건 백트래킹을 마무리할때 어떻게 할건지
- 위에 중단 조건으로 마무리 되고나고 다른 방식을 찾을 때 방문을 취소하는 법
이거 두개만 지키면 해결 가능하다.
def dfs(depth, idx):
    global min_diff
    if depth == n//2:
        power1, power2 = 0, 0
        for i in range(n):
            for j in range(n):
                if visited[i] and visited[j]:
                    power1 += graph[i][j]
                elif not visited[i] and not visited[j]:
                    power2 += graph[i][j]
        min_diff = min(min_diff, abs(power1-power2))
        return

    for i in range(idx, n):
        if not visited[i]:
            visited[i] = True # 일단 팀에 추가하고
            dfs(depth+1, i+1) # 턴 보내버리고
            visited[i] = False # 다시 그 사람은 팀에서 추방

n = int(input())

visited = [False for _ in range(n)]
graph = [list(map(int, input().split())) for _ in range(n)]
min_diff = int(1e9)

dfs(0, 0)
print(min_diff)
--------------------------------------------------------------------------------------------------------------
테트로미노
완탐으로, 전부 백트래킹 해서 모양을 알아봐야함
대신, ㅗ 모양은 예외처리로 따로 해줘야한다.
if a + maxv*(4-count) <= max_value: # 기준을 최대값으로 전부 곱해서 더했는데도 작다면 더이상 할 필요가 없어짐.
    return
위 부분이 제일 신박했고, 굳이 더 이상 진행할 필요가 없는 백트래킹 조건이었음


import sys
input = sys.stdin.readline

n, m = map(int, input().split())

g = [list(map(int, input().split())) for _ in range(n)]

dx, dy = [-1,1,0,0], [0,0,-1,1]
c = 0

maxv = max(map(max, g))
max_value = 0

def dfs(x,y, count, a):
  global max_value

  if a + maxv*(4-count) <= max_value: # 기준을 최대값으로 전부 곱해서 더했는데도 작다면 더이상 할 필요가 없어짐.
    return

  if count == 4: # 블록이 4개면 완성
    max_value = max(max_value, a)
    return

  for i in range(4):
    nx = x + dx[i]
    ny = y + dy[i]

    if 0<= nx<n and 0<= ny <m and visit[nx][ny] == 0:

      if count == 2: # ㅗ 모양 때문에 2칸만 전진하고 그 자리에서 다시 새출발한다는 느낌.
        visit[nx][ny] = 1
        dfs(x,y,count+1,a+g[nx][ny])
        visit[nx][ny] = 0
      
      visit[nx][ny] = 1 # ㅗ모양 말고, 나머지 이외 모양들은 원래대로 진행
      dfs(nx,ny,count+1,a+g[nx][ny]) # 모양 만들러 더 진행
      visit[nx][ny] = 0 # 다 만들었으면 다시 전부 방문 해제 해줌.
      
visit = [[0]*m for _ in range(n)]

for i in range(n):
  for j in range(m):
    visit[i][j] = 1
    dfs(i,j, 1, g[i][j])
    visit[i][j] = 0 # 다 만들었으면 다시 전부 방문 해제 해줌.

print(max_value)
---------------------------------------------------------------------------------------------------------------
다리 놓기
당연히 조합문제인줄 알았는데, dp로도 하나하나 규칙써서 풀면 가능하긴 했음.
combinations 쓰려다가 n, m커져서 메모리 오류 계속 났었음.
그래서 개수만 알고싶을때는, math.comb 쓰면된다~~~~

import sys

input = sys.stdin.readline

import math

t = int(input())

for _ in range(t):
    n, m = map(int, input().split(' '))
    print(math.comb(m, n)) #갯수만 알고싶으면 combinations 보다 효율적임.
---------------------------------------------------------------------------------------------------------------
LCS
아 입력이 1000글자여서, 시간복잡도 두번이면 어차피 백만밖에 안되네,,,
그럼 거의 완탐이었구나,, 하 ,,,
S1: A
S2: C
두 문자열로 만들 수 있는 LCS의 길이는 0이다.
 
S1: A
S2: CA
두 문자열로 만들 수 있는 LCS의 길이는 1이다.
 
S1: A
S2: CAP
두 문자열로 만들 수 있는 LCS의 길이는 1이다.

위에처럼
점화식 세우는건 역시 규칙이 젤 어려워,, 좀 나란히 순서대로 좀 써보고라도 생각하자 명윤아아제발

import sys

input = sys.stdin.readline

f = input()
s = input()

len1 = len(f)
len2 = len(s)
matrix = [[0] * (len2 + 1) for _ in range(len1 + 1)]

for i in range(1, len1 + 1):
    for j in range(1, len2 + 1):
        if f[i - 1] == s[j - 1]: # 같은 글자면, 표에서 대각선 으로 1 증가
            matrix[i][j] = matrix[i - 1][j - 1] + 1
        else: # 서로 다른 글자면, 이전 라인들의 최대로 넣음
            matrix[i][j] = max(matrix[i - 1][j], matrix[i][j - 1])

print(matrix[-1][-1]) # 제일 마지막인 최대값 출력
---------------------------------------------------------------------------------------------------------------
토마토2
여러곳에서 시작하는 bfs라 큐에 박고 시작함.
3차원 bfs는 신박했음. 처음 리스트 선언이나, 방향벡터도 6개로 만들고 재밌었음.
나머지 응용부분은 그냥 2차원과 똑같다고 보면됨.

import sys

input = sys.stdin.readline

from collections import deque

n, m, h = map(int, input().split())
g = [ [list(map(int, input().split())) for _ in range(m)] for _ in range(h) ] # 3차원 이것도 신박하긴했음.

# 3차원의 방향벡터
dx = [-1, 1, 0, 0, 0, 0]
dy = [0, 0, -1, 1, 0, 0]
dz = [0, 0, 0, 0, -1, 1]

q = deque()

for i in range(h): # 먼저 큐에 박아놓고 시작함
    for j in range(m):
        for k in range(n):
            if g[i][j][k] == 1:
                q.append((i, j, k))

while q:
    pz, px, py = q.popleft()

    for k in range(6): # 위, 아래도 포함해서 총 6개
        mz = pz + dz[k]
        mx = px + dx[k]
        my = py + dy[k]

        if 0 <= mz < h and 0 <= mx < m and 0 <= my < n:
            if g[mz][mx][my] == 0:
                g[mz][mx][my] = g[pz][px][py] + 1
                q.append((mz, mx, my))

c = 0
for i in g:
  for j in i:
    if 0 in j: # 0이 존재하면 -1출력
      print(-1)
      exit()
    c = max(c, max(j)) # 최대 갱신

print(c-1) # 1에서 시작해서 마지막엔 -1 해줘야 함
---------------------------------------------------------------------------------------------------------------
치킨 배달
n, m이 보기좋게 작은 조건 보니까 왠지 완탐문제 같았음.
지도문제여서 bfs, dfs 착각할만한 문제였지만, 아니나 다를까 전부 구해서 최소 구하는 것 같아 완탐임

각 집에서 치킨집들 최소거리를 구해서 총 거리를 구하고, 또 그 총거리 중에서 최솟값이 답이었음..
출력이 참 생각하기 어려웠다 제발 정신차리자 머리좀 굴려라!!!!!!!!
for i in combinations(c, m): # 치킨집 섞은 조합
이 부분을 바로 쓰는거 자체도 가시적이 아니라 이해가 안갔다... 이제는 이해감! 조합 바로 쓸 수 있었음!

import sys

input = sys.stdin.readline

from itertools import combinations

n, m = map(int, input().split())
g = [list(map(int, input().split())) for _ in range(n)]

d = []
c = []

for i in range(n):
  for j in range(n):
    if g[i][j] == 1:
      d.append([i,j])
    elif g[i][j] == 2:
      c.append([i,j])

result = 1000000

for i in combinations(c, m): # 치킨집 섞은 조합
  s = 0
  for j in d: # 집 고르기
    k = 100000
    for t in range(m): # 치킨집 고르기
      k = min(k, abs(i[t][0]-j[0])+abs(i[t][1]-j[1])) # 고른 집에서 치킨집들 최소거리 더하기
    s += k # 각 집의 최소거리들을 더해서 총 거리 구하기

  result = min(result, s) # 가능한 치킨집 조합들에서 나온 총 거리 중, 최소값 갱신

print(result)
---------------------------------------------------------------------------------------------------------------
스티커

import sys

input = sys.stdin.readline

n = int(input())

for _ in range(n):
    g = []
  
    m = int(sys.stdin.readline())
    dp = [[0 for i in range(m)] for j in range(2)]
  
    for p in range(2):
        g.append(list(map(int , sys.stdin.readline().split(" "))))
    if m != 1:
        dp[0][0] = g[0][0]
        dp[1][0] = g[1][0]
        dp[0][1] = g[0][1] + g[1][0]
        dp[1][1] = g[1][1] + g[0][0]
      
        for i in range(2,m):
            dp[0][i] = max(dp[1][i-1],dp[1][i-2]) + g[0][i]
            dp[1][i] = max(dp[0][i - 1], dp[0][i - 2]) + g[1][i]
        print(max(dp[0][m-1],dp[1][m-1]))
    else:
        print(max(g[0][0],g[1][0]))
---------------------------------------------------------------------------------------------------------------
동전2
동전을 만들때 10원을 만든다치고 지금 3원을 골랐다하면, 
d[7](7원 만드는 최소갯수) + 1(3원 갯수) 이다.
따라서 전체의 동전갯수마다 경우를 따져야하니, 
for j in g: # 지금 고르는 동전마다
    if i < j: continue # 하지만 만약, 10원을 만드려는데 12원을 골라버리면 패스이다.
    dp[i] = min(dp[i], dp[i-j] + 1) # dp[n] = min(dp[n-1], dp[n-5], dp[n-8]) + 1 # 10원을 만들기위해 1, 3, 5원 동전을 골랐을때 최솟값을 계속 갱신한다.

import sys

input = sys.stdin.readline

n, k = map(int, input().split())

g = [int(input()) for _ in range(n)]

dp = [10001 for _ in range(k+1)] # 전체 돈이 만원까지라서, 처음 비교할때 영향을 없애기 위해, +1을 해준다.

dp[0] = 0

for i in range(1, k+1):
  for j in g:
    if i < j: continue
    dp[i] = min(dp[i], dp[i-j] + 1) # dp[n] = min(dp[n-1], dp[n-5], dp[n-8]) + 1

if dp[k] == 10001: print(-1)
else: print(dp[k])
---------------------------------------------------------------------------------------------------------------
2×n 타일링 2
이전에서 이미 포함해서 계산하기때문에, 앞에다 블록 세우느니 중간에 있다느니, 깊게 생각할 필요없고,
끝부분만 블록 세우거나 엎었을때로 그림 그리면 된다.
1.한개 세워졌을때와, 
두개로 만들 수 있는, 
2.두개 엎은거 
3.아예 사각형 
이 세가지를 각각 따로 생각해보면, 총 dy[i] = dy[i-1]+2*dy[i-2] 이런 점화식이 나옴.

import sys
input = sys.stdin.readline

n = int(input())
dy = [0]*(n+1)

dy[0] = 1
dy[1] = 1

for i in range(2,n+1):
  dy[i] = dy[i-1]+2*dy[i-2]

print(dy[n]%10007)
---------------------------------------------------------------------------------------------------------------
암호 만들기
전형적인 dfs 백트래킹 이었다.
if len(s)==l and 0<s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')<l-1:
이렇게 모음 갯수 세는거 신박했음.
s.append(arr[i])
        dfs(i+1)
        s.pop()
2번 풀이의 그냥 추가하고 더 깊이들어가고, 다시 빼는 스킬을 더 연마하자
1번 풀이는 내 풀이

1.
import sys
input = sys.stdin.readline

l, m = map(int, input().split())
g = list(input().split())
g.sort()

visit = [0] * m
r = []

def dfs(str, idx):

  if len(str) == l:
    mo = 0
    ja = 0
    for i in str:
      if i in ['a','e','i','o','u']:
        mo += 1
      else:
        ja += 1

    if mo >= 1 and ja >=2:
      r.append(str)
      return
  
  for i in range(idx, m):
    if visit[i] == 0:
      visit[i] = 1
      dfs(str + g[i], i+1)
      visit[i] = 0
    
s = ''
i= 0

dfs(s, i)

for i in r:
  print(i)

2. count로 갯수세는거, 백트래킹 신박했음!
l,c=map(int,input().split())
arr=list(input().split())
arr.sort()
s=[]

def dfs(a):
    if len(s)==l and 0<s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')<l-1:
        print(*s)
        return
    for i in range(a,c):

        s.append(arr[i])
        dfs(i+1)
        s.pop()
dfs(0)
--------------------------------------------------------------------------------------------------------------
숨바꼭질 3
그냥 최단거리라 아무리 생각해봐도 전형적인 bfs 문제였다.
내가 헷갈린걸 해결한 생각은 (이미 그 위치를 한번 방문했으면 그 값 고정이다 -> 왜냐면 그보다 나중에 방문한 것들은 이미 최단거리가 아니기 때문!)
나는 이미 한번 방문했던 곳에 또 도착해서 값이 바껴도 되는거 아닌가?라는 생각이었는데, 역시 쓰잘데기없는 생각이었다. 
제일 중요한건, x*2가 제일 먼저 방문해야 하기때문에, deque에 appendleft로 가장 먼저 붙여준다.

import sys
input = sys.stdin.readline

from collections import deque

def search(N):

    visited = [0] * 100001 # 방문을 일단 최대 범위로 지정하는 것도 중요!~~~~~~~~
    Q = deque()
    Q.append(N)

    while Q:
        position = Q.popleft()
        if position == K:
            return visited[position]

        for next_position in (position + 1, position - 1, position * 2) : # 이것도 중요!~~~~~~~~

            if 0 <= next_position < 100001: # 아 물론 범위 설정도 중요함!!!!!!~~~~~~~~~~~~~~~~
                if visited[next_position] == 0:
                    if next_position == position * 2 and next_position != 0:
                        visited[next_position] = visited[position]
                        Q.appendleft(next_position) # 제일 중요함!!!!~~~~~~~~~~~~~~~~~~~~~~~~
                    else:
                        visited[next_position] = visited[position] + 1
                        Q.append(next_position)

N, K = map(int, input().split())
answer = search(N)
print(answer) 
--------------------------------------------------------------------------------------------------------------
빙산
일단 제일 개그튼 bfs 문제였고, 아니지 그냥 내가 멍청하거지!!!!!!!!!!!!!!!!!!!! 하.,
함수를 각각 차근차근 순서대로 생각하면 나쁘지 않은 문제였다.(역시 한글로 써야하나? 코딩애플센세?)
1. 주변에 붙어있는 빙산알갱이 찾는 함수
2. 그냥 일반적인 빙산덩어리 몇개 있는지 찾는 함수
2. 지금 현재 탐색해봤을때 얼음이 아예 없으면, 그냥 바로 0 출력
3. 이제 녹이는 작업, 중요한건 from copy import deepcopy해서 녹이기전의 temp_g = deepcopy(g)해서 
-> if temp_g[i][j] != 0: # 녹이기전이랑 비교하려고, 일단 deepcopy함.
4. 마지막으로 1년 주변꺼 다 녹인거로, 덩어리 갯수 체크, 떨어져 있는 갯수 나오면 출력, 아니면 year += 1 

import sys

input = sys.stdin.readline

# deepcopy용 import
from copy import deepcopy
from collections import deque

dx, dy = [-1,1,0,0], [0,0,-1,1]

# 빙산 주변 갯수 세기
def count_ad(x, y):
  c = 0

  for i in range(4):
    nx = x + dx[i]
    ny = y + dy[i]

    if 0<=nx<n and 0<=ny<m:
      if temp_g[nx][ny] == 0:
        c += 1

  return c


# 덩어리의 각 빙산세기:
def count_ice(startx,starty):
  q = deque()
  q.append((startx,starty))
  visit[startx][starty] = 1

  while q:
    x, y = q.popleft()

    for i in range(4):
      nx = x + dx[i]
      ny = y + dy[i]

      if 0<=nx<n and 0<=ny<m and g[nx][ny] != 0 and visit[nx][ny] ==0:
        visit[nx][ny] = 1
        q.append((nx,ny))


n, m = map(int, input().split())
g = [list(map(int, input().split())) for _ in range(n)]
year = 1

# 1년씩 반복
while True:
  visit = [[0]*m for _ in range(n)]
  piece = 0

  # 빙산이 다 녹았을 때 까지 분리 안된거 체크
  f = True
  for i in range(n):
    for j in range(m):
      if g[i][j] != 0:
        f = False
  if f:
    print(0)
    break

  # 빙산 한번 녹을때 마다 업데이트
  temp_g = deepcopy(g)
  for i in range(1,n-1):
    for j in range(1,m-1):
      if temp_g[i][j] != 0: # 녹이기전이랑 비교하려고, 일단 deepcopy함.
        g[i][j] = max(0, g[i][j] - count_ad(i, j))

  # 1년에 주변꺼 다 녹인거로 비교
  for i in range(1,n-1):
    for j in range(1,m-1):
      if not visit[i][j] and g[i][j] != 0:
        count_ice(i,j)
        piece += 1

  if piece >= 2:
    print(year)
    break
  
  year+=1
--------------------------------------------------------------------------------------------------------------
제곱수의 합
이번엔 직감적으로 dp라는 느낌이 빡! 왔고, 무조건 규칙 찾으려고 나열했다!
후 혼자 고생좀 했는데, 맞히긴 했다.,,, 무조건 나열하기로 다짐 또 다짐!!!!!!!
이전꺼랑 안간힘으로 비교하려고 좀 애써본 문제였다.

import sys
import math

input = sys.stdin.readline

n = int(input())

dp = [100000] * (n+1)

for i in range(n+1):
  if i <= 3:
    dp[i] = i
  else:
    for j in range(1,int(math.sqrt(n))+1):
      dp[i] = min(dp[i],dp[i-j**2] + 1)

print(dp[n])
--------------------------------------------------------------------------------------------------------------
동전 1
아니 dp는 해도해도 새롭냐 ;; 빢친닮언ㅇ리ㅏ ㅁㄴㄴㅇ라
동전한개씩 구하는거 저번에 했잔ㅇ항이 새기야 제발 기억좀 해라 아이디어좀!!

import sys

input = sys.stdin.readline

n, k = map(int, input().split())
c = []
dp = [0 for i in range(k + 1)]
dp[0] = 1

for i in range(n):
    c.append(int(input()))

for i in c: # 동전한개씩 고르는걸 왜 이해 못하냐 명윤아??? 에효ㅛ ㅄㅂ ㅅ4ㄷㅂㅈㅅㅂㅈㄷ
    for j in range(1, k + 1):
        if j >= i: # 작으면 확인할 필요가 없어서 조건
            dp[j] = dp[j] + dp[j - i] # 기존만드는 경우의 수에 + 고른 동전은 무조건 포함할 예정이니까, 동전 뺀거를 만드는 경우의 수
print(dp[k])
--------------------------------------------------------------------------------------------------------------
트리의 부모찾기
문제에서 'n-1개의 줄에'라고 반복횟수 알려줬는데, 문제를 잘 안읽어서 헛짓거리함
제발 이런거좀 하지마라,,,,,,,,

import sys
sys.setrecursionlimit(10000000) # 반복횟수 해제 중요!

input = sys.stdin.readline

n = int(input())
g = list([]*(n+1) for _ in range(n+1))

visit = [0] *(n+1) 

re = [0] * (n+1)

def dfs(s):
  if visit[s] == 0:
    visit[s] = 1

    for i in g[s]:
      dfs(i)
      re[i] = s

for i in range(n-1):
  a, b = map(int, input().split())
  g[a].append(b)
  g[b].append(a)

dfs(1)

for i in range(2,n+1):
  print(re[i])
--------------------------------------------------------------------------------------------------------------
인구이동
뭐 생각은 bfs로 완벽하게 로직은 다 짜고 했는데, 아니 무슨 마지막 인구이동이 시작되면 해주는, 플래그를 못 세워서 시간 다 날림;;
1. while True:에 flag= False 하고 이동하면 바로, True 해주면 됨.
2. 그리고 이동 안했으면 그대로, False니까 break 먹여줌. 이지! 하,, 이거 저번에도 못했는데 좀 기억좀 해라 제발;;
참고로 이런 문제같이, 
반복문을 돌면서 더이상 ~~ 불가능할때까지 반복. 이러는 조건이면 무조건 flag 박자!!!!!!!!!!!!!!!!!!!!!

import sys
input = sys.stdin.readline
from collections import deque

graph = []
n,l,r = map(int,input().split())
for _ in range(n):
    graph.append(list(map(int,input().split())))

dx = [0,0,1,-1]
dy = [1,-1,0,0]
def bfs(a,b):
    q = deque()
    temp = []
    q.append((a,b))
    temp.append((a,b))
    while q:
        x,y = q.popleft()
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if 0<=nx<n and 0<=ny<n and visited[nx][ny] == 0:
                # 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다.
                if l<=abs(graph[nx][ny]-graph[x][y])<=r:
                    visited[nx][ny] = 1
                    q.append((nx,ny))
                    temp.append((nx,ny))
    return temp
            
result = 0
while 1:
    visited = [[0] * (n+1) for _ in range(n+1)]
    flag = 0
    for i in range(n):
        for j in range(n):
            if visited[i][j] == 0:
                visited[i][j] = 1
                country = bfs(i,j)
                # 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.
                if len(country) > 1:
                    flag = 1
                    # 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다.
                    number = sum([graph[x][y] for x, y in country]) // len(country)
                    for x,y in country:
                        graph[x][y] = number
    # 연합을 해체하고, 모든 국경선을 닫는다.
    if flag == 0:
        break
    result += 1
print(result)
--------------------------------------------------------------------------------------------------------------
오르막수
그냥 전형적인 dp 문제라고 생각했고, 바로 나열해서 규칙찾으려고 시전함.,,
혼자 복잡하게 나열하다 이건 아니다 싶어서 단순하게 나열해서 규칙을 찾았다. 
찾고보니 합을 구하기위해선 이차원dp로 메모이제이션하는게 편할거같았다.
혼자 힘으로 dp 계속 풀리다보니, 나름 재밌어지는듯? ㅎ,,,

import sys
input = sys.stdin.readline

n = int(input())

dp = [[1]*10 for _ in range(n)]

for i in range(1,n):
  for j in range(1,10):
    dp[i][j] = dp[i-1][j]+dp[i][j-1] # 이전꺼랑, 이전 줄에서 그 위치 더함
    
print(sum(dp[n-1])%10007) 
-----------------------------------------------------------------------------------------------------------
신입사원
서류 1위는 무조건 채용이고, 서류로는 이미 이겼으니 면접 순위만 보면 되는거임 ㅇㅇ.
이런 min, max 를 for문 비교 과정에서 바꿀줄 아는 스킬을 길러야함. -> 계산량을 줄이기위해!

import sys
input = sys.stdin.readline

T = int(input()) #테스트케이스

for i in range(0,T):
    Cnt = 1 # 정렬된 상태의 서류 1위는 무조건 채용이니깐, 1명은 확보 ㅇㅇ
    people = []
    
    N = int(input())
    for i in range(N):
        Paper, Interview = map(int,sys.stdin.readline().split())
        people.append([Paper, Interview])

    people.sort() # 앞 인덱스인 서류 기준 오름차순. 참고(s1 = sorted(g, key = lambda x : x[0])   ->  x[0]기준으로 정렬됨
    Max = people[0][1] #서류 1위의 면접순위 -> 서류 기준으로 정렬했으므로, 면접순위만 보면 됨.
    
    for i in range(1,N):
        if Max > people[i][1]: #이미 서류순위로 졌던 이후사람이, 면접순위가 더 높으면 
            Cnt += 1 # 그 이후사람을 채용.
            Max = people[i][1] # 그 이후사람의 면접 순위로 교체 -> 어차피 그 사람 이후부터 또 검사하므로, 면접순위만 교체해서 똑같이 이후 비교하면 됨.

    print(Cnt)
--------------------------------------------------------------------------------------------------------------
타일 채우기
진짜 걍 무지성으로 그리는구나;; 얼마나 나오던 그냥 그리고 보는구나;; ㄹㅇ 대단하다 진짜;

가로가 0인 타일묶음 한 개에 가로가 6인 타일묶음 한 개 추가
  가로가 0인 타일묶음의 경우의 수는 0이다. 나눌 수 없는 가로가 6인 타일묶음의 수는 가로가 4인 타일묶음과 같이 2개이다.
-> 11*3 + 3*2 + 2 = 41
 
즉, 나눌 수 없는 가로가 2인 타일묶음을 추가하는 경우의는 3을 곱해주고, 
나눌 수 없는 가로가 4, 6, 8...인 타일묶음을 추가하는 경우의는 2를 곱해주면 된다. 
이것을 알아내는데 오래걸렸다. -> 블로그를 참고했는데도 이해하기 힘들다. 진짜 이 문제는 역대급으로 어렵다;;

import sys

N = int(sys.stdin.readline())
cases = [0] * 31
cases[2] = 3

for i in range(4, N+1, 2): # 4번째부터는 세로로 나눌수가 없으니까, 곱할때 2씩이다.
    cases[i] = 2 + cases[i-2] * 3 + sum(cases[:i-2]) * 2
--------------------------------------------------------------------------------------------------------------
탈출
토마토 문제처럼 여러 정점에서 출발하는 bfs => 먼저 큐에 다 넣고 시작함!~!!!!!!!!!!!!!!!
대신 물을 큐에 넣을 때 먼저 다 넣어주거나, appendleft를 사용해서 앞쪽에 배치해야 함!!!

from collections import deque
import sys

def input():
  return sys.stdin.readline().rstrip()

R, C = map(int, input().split())

board = []
visited = [[False for _ in range(C)] for _ in range(R)]

for _ in range(R):
  board.append(list(input()))
  
cnt = 0
success = False
q = deque([])
dir =[(-1,0),(1,0),(0,1),(0,-1)]

for r in range(R):
  for c in range(C):
    if board[r][c] == "*": # 물
      q.append(("*", 0, r,c))
      
for r in range(R):
  for c in range(C):
    if board[r][c] == "S": # 고슴도치
      q.append(("S", 0, r, c))
      visited[r][c] = True
      
while q:
  what, cnt, now_r, now_c = q.popleft()
  for _r, _c in dir:
    nxt_r, nxt_c = now_r + _r, now_c + _c
    if not (0<=nxt_r<R) or not (0<=nxt_c<C):
      continue
    if what == "*": # 물
      if board[nxt_r][nxt_c] == ".":
        board[nxt_r][nxt_c] = "*" # 범람시키기
        q.append((what, cnt+1, nxt_r, nxt_c))
    else:
      if visited[nxt_r][nxt_c]:
        continue
      if board[nxt_r][nxt_c] == ".": # 고슴도치
        q.append((what, cnt+1, nxt_r, nxt_c))
        visited[nxt_r][nxt_c] = True
      elif board[nxt_r][nxt_c] == "D": # 굴 도착
        success = True
        break
  if success:
    break

if success:
  print(cnt+1) # 도착전 cnt 의 + 1 
else:
  print("KAKTUS")
  
  
  N = int(input())
p = [0] + list(map(int,input().split()))
dp = [0 for _ in range(N+1)]
---------------------------------------------------------------------------------------------------------------
카드 구매하기
ex) dp[3] = p[1]+dp[2] or p[2]+dp[1]
전형적인 dp이고, 입력 p를 dp에 이용하기위해선,
처음에 한칸 띄어주려고 p.insert(0,0) # 인덱스 0 위치에 0을 추가해줌.

import sys

input = sys.stdin.readline

n = int(input())
p = list(map(int, input().split()))
p.insert(0,0) # 인덱스 0 위치에 0을 추가해줌.

dp = [0 for _ in range(n+1)]

for i in range(1, n+1):
    for j in range(1,i+1):
        dp[i] = max(dp[i], p[j] + dp[i-j])
      
print(dp[n])
--------------------------------------------------------------------------------------------------------------
리모컨
역시 50만정도여도 무조건 스킬이아니라, 은근히 완탐문제가 많다는걸 다시 느낌.
문제가 어려울수록 코드가 짧다 -> 그만큼 아이디어를 뽑아내야함.
여기서는 낮고 높은 경우로 총 2개를 따져야하니, 모든 전범위는 50만*2인 100만이 됨!!!!!
그 100만의 범위의 모든 수를 전부 다 따져보면 됨!

import sys

input = sys.stdin.readline

n = int(input())
m = int(input())
b = list(map(int, input().split()))

min_count = abs(100 - n)# 현재 위치 100기준, 횟수 

# 현재 채널에서 낮은, 높은 경우 2개 따져야하니까, 아예 범위를 2배로!!
for num in range(1000001):
  num = str(num)

  for i in range(len(num)):
    if int(num[i]) in b:# 고장난 버튼이 있다면, 이 수는 탈락
      break
    elif i == len(num) - 1: # 끝까지 버튼이 안 고장났으면
      min_count = min(min_count, len(num) + abs(int(num) - n)) # 최소값과, 현재 수 치는 횟수 + 수정하는 횟수와 비교 갱신.

print(min_count)
--------------------------------------------------------------------------------------------------------------
연산자 끼워넣기
걍 완탐에다가, 백트래킹일거 같았다. visit으로 true하고 방문처리하고 보내고, 다시 false로 만드는 백트래킹으로 할수도있엇지만,
그냥 매개변수 자체만 계속 만져서 코딩함.
아 그리고 최저, 최대값 초기화할때 완전 작고, 크게 만들자!!! 
첨에 max = 0으로만 했다가, 처음에 바로 음수일때 갱신이 안되서 틀렸다!! 그래서 -1000000으로,, ㅎ,,
이런 바로 틀리는 예외들은 항상 처음이나 끝에 존재하니까, 코테할때도 이런거 검사 잘하자 알겟냐??

참고
1. 음수 / 양수의 몫 = int(음수 / 양수) = 소수점 컷! = -7 / 2 = -3
2. (음수 // 양수) = -7 // 2 = -4

import sys

input = sys.stdin.readline

n = int(input())
num = list(map(int, input().split()))
p, m, mu, d = map(int, input().split())

max_s = -10000000000000 # 최저값할때도, 아예 완전 작게 해버리자!!
min_s = 1000000000 # 최대값도 완전크게!!

def dfs(k, i, pl, mi, mul, di):
  global max_s, min_s

  if i == n-1:
    max_s = max(max_s, k)
    min_s = min(min_s, k)
    return 

  #매번 변수자체에다가 값 수정
  if pl > 0:
    dfs(k+num[i+1], i+1, pl-1, mi, mul, di)

  if mi > 0:
    dfs(k-num[i+1], i+1, pl, mi-1, mul, di)

  if mul > 0:
    dfs(k*num[i+1], i+1, pl, mi, mul-1, di)

  if di > 0:
    if k >= 0:
      dfs(k//num[i+1], i+1, pl, mi, mul, di-1)
    else:
      dfs(int(k/num[i+1]), i+1, pl, mi, mul, di-1)
   
dfs(num[0], 0, p,m,mu,d)

print(max_s)
print(min_s)
--------------------------------------------------------------------------------------------------------------
이분 그래프
이분 그래프는 서로 인접한 노드끼리 색깔이 다른 표시를 -1 *visit형식으로 해줌!!
또 아예 안 이어진 그래프도 존재할 수 있으니, 애초에 모든 점을 다 탐색해봐야 함.
visited[w] = -1 * visited[v] # 이렇게 양수, 음수로 현재 노드와 다른 그룹 지정!!

import sys
sys.setrecursionlimit(10 ** 5)
from collections import deque

input = sys.stdin.readline

t = int(input())

for i in range(t):
  
  v, e = map(int, input().split())
  visit = [0]*(v+1)
  g = [[] for _ in range(v+1)]

  for i in range(e):
    s, d = map(int, input().split())
    g[s].append(d)
    g[d].append(s)

  q = deque()
  flag = True # 일다 성공으로 플래그!

  for i in range(1, v+1):
    if visit[i] == 0:
      q.append(i)
      visit[i] = 1

      while q:
        x = q.popleft()
        
        for j in g[x]:
          if visit[j] ==0:
            visit[j] = -1 * visit[x] # 인접한건 -1 곱해서 서로 다른 그룹으로 지정.
            q.append(j)
          elif visit[j] == visit[x]: # 이미 이전 부모원소 때 방문은 했는데, 심지어 현재 같아버리면 이분 안되는거임 ㅇㅇ 
            flag = False # 그래서 실패

  print('YES' if flag else 'NO')
--------------------------------------------------------------------------------------------------------------
안전영역
dfs 오랜만에 하니까 이걸 까먹네;;
k = max(map(max,g)) #최대 높이만 보면 되니깐! 기억!
  
  import sys
sys.setrecursionlimit(10 ** 5)

input = sys.stdin.readline

n = int(input())
g = [list(map(int, input().split())) for _ in range(n)]

k = max(map(max,g)) #최대 높이만 보면 되니깐!

def dfs(x, y):
  if 0<= x < n and 0<= y<n: # 이걸 까먹었네;; 분발하자;
    if visit[x][y] == 0 and g[x][y] > t: # 최대높이 보다 큰건 방문
      visit[x][y] = 1 
      dfs(x+1, y)
      dfs(x, y+1)
      dfs(x-1, y)
      dfs(x, y-1)

re = 0

for t in range(k):
  c = 0
  
  visit = [[0]*n for _ in range(n)] # 매 횟수마다, 다시 첨 부터 방문
  for i in range(n):
    for j in range(n):
        if visit[i][j] == 0 and g[i][j] > t:
          dfs(i,j)
          c+=1
      
  re = max(re, c)
  
print(re)
--------------------------------------------------------------------------------------------------------------
안전영역
dfs 오랜만에 하니까 이걸 까먹네;;
k = max(map(max,g)) #최대 높이만 보면 되니깐! 기억!
  
  import sys
sys.setrecursionlimit(10 ** 5)

input = sys.stdin.readline

n = int(input())
g = [list(map(int, input().split())) for _ in range(n)]

k = max(map(max,g)) #최대 높이만 보면 되니깐!

def dfs(x, y):
  if 0<= x < n and 0<= y<n: # 이걸 까먹었네;; 분발하자;
    if visit[x][y] == 0 and g[x][y] > t: # 최대높이 보다 큰건 방문
      visit[x][y] = 1 
      dfs(x+1, y)
      dfs(x, y+1)
      dfs(x-1, y)
      dfs(x, y-1)

re = 0

for t in range(k):
  c = 0
  
  visit = [[0]*n for _ in range(n)] # 매 횟수마다, 다시 첨 부터 방문
  for i in range(n):
    for j in range(n):
        if visit[i][j] == 0 and g[i][j] > t:
          dfs(i,j)
          c+=1
      
  re = max(re, c)
  
print(re)
--------------------------------------------------------------------------------------------------------------
안전영역
dfs 오랜만에 하니까 이걸 까먹네;;
k = max(map(max,g)) #최대 높이만 보면 되니깐! 기억!
  
  import sys
sys.setrecursionlimit(10 ** 5)

input = sys.stdin.readline

n = int(input())
g = [list(map(int, input().split())) for _ in range(n)]

k = max(map(max,g)) #최대 높이만 보면 되니깐!

def dfs(x, y):
  if 0<= x < n and 0<= y<n: # 이걸 까먹었네;; 분발하자;
    if visit[x][y] == 0 and g[x][y] > t: # 최대높이 보다 큰건 방문
      visit[x][y] = 1 
      dfs(x+1, y)
      dfs(x, y+1)
      dfs(x-1, y)
      dfs(x, y-1)

re = 0

for t in range(k):
  c = 0
  
  visit = [[0]*n for _ in range(n)] # 매 횟수마다, 다시 첨 부터 방문
  for i in range(n):
    for j in range(n):
        if visit[i][j] == 0 and g[i][j] > t:
          dfs(i,j)
          c+=1
      
  re = max(re, c)
  
print(re)
--------------------------------------------------------------------------------------------------------------
괄호 추가하기
전형적인 백트래킹이라 생각함.
def calculate(a, op, b):
    return str(eval(a+op+b)) // str(eval(값+연산자+값)) 아주 스무스한 계산법이다!

import copy
import sys
input = sys.stdin.readline
MAX = sys.maxsize

N = int(input())
arr = input().strip()
nums = []
op = []
for i, x in enumerate(arr):
    if i % 2 == 0:
        nums.append(x)
    else:
        op.append(x)

def calculate(a, op, b):
    return str(eval(a+op+b))


def calculate_front(arr):
    result = arr[0]
    for i in range(1, len(arr)-1, 2):
        result = calculate(result, arr[i], arr[i+1])
    return result


def dfs(index, arr, is_used):
    global answer
    if index == len(op):
        answer = max(answer, int(calculate_front(arr)))
        return
    if is_used:
        temp = copy.deepcopy(arr)
        temp.append(op[index])
        temp.append(nums[index+1])
        dfs(index+1, temp, False)
    else:
        temp = copy.deepcopy(arr)
        temp.append(op[index])
        temp.append(nums[index+1])
        dfs(index+1, temp, False)
        temp.pop()
        temp.pop()
        temp.pop()
        temp.append(calculate(nums[index], op[index], nums[index+1]))
        dfs(index+1, temp, True)


answer = -MAX
dfs(0, [nums[0]], False)
print(answer)
--------------------------------------------------------------------------------------------------------------
퇴사
역방향으로 해야한다는 점이 핵심!
역방향도 역방향인데, 그냥 생각하는거 자체가 개어려웠음 하,,,
설명을 봐도 뭔 소린지 모르겟는 문제는 거의 처음이었다,, 그 정도 문제는 아닌거같은데,,
하루하루 예시 다 적어가면서 한후에나 겨우 이해라도 됨.. 

참고
각 팀의 회의 시작 시간과 회의 시간이 정해진 타임 테이블에서 최대한 많은 회의를 잡으려고 하는
 dp와 비슷

import sys
readline = sys.stdin.readline

N = int(readline())
T, P = [], []
for _ in range(N):
    t, p = map(int, readline().split())
    T.append(t) # 일과 수입을 따로따로
    P.append(p) # 수입

d = [0] * (N+1)

for i in range(N - 1, -1, -1): # 제일 중요한 역방향으로~~~~~~~~~~~~~~~~~~~~~~~~
    # i일에 상담을 하는 것이 퇴사일을 넘기면 상담을 하지 않음
    if i + T[i] > N:
        d[i] = d[i+1] # 이날 상담안해도 넣어줘야한다.
    else:
        # i일에 상담을 하는 전제, 이날 상담을 안하고 다음날부터 한다는 전제 중 큰 것을 선택
        d[i] = max(d[i+1], P[i] + d[i + T[i]])

print(d[0]) 
--------------------------------------------------------------------------------------------------------------
주사위 굴리기
그냥 구현이라고는 생각했지만, 정육면체에서 각 상황일때 원소 박는거에 진짜 감동먹음,,, ㄹㅇ,,,
for i in kli:
  x = x +dx[i-1]
  y = y +dy[i-1] 
또 이거처럼 방향 그대로 지정?하는것을 몸으로 체화한 느낌,,, 후,,

import sys
sys.setrecursionlimit(10 ** 5)

input = sys.stdin.readline

n, m, x, y, k = map(int, input().split())
g = [list(map(int, input().split())) for _ in range(n)]
kli = list(map(int, input().split()))
dice = [0] * 6

def turn(dir):  # 이게 진짜 ㄹㅇ이었다,,,
    a, b, c, d, e, f = dice[0], dice[1], dice[2], dice[3], dice[4], dice[5]
    if dir == 1: #동
        dice[0], dice[1], dice[2], dice[3], dice[4], dice[5] = d, b, a, f, e, c

    elif dir == 2: #서
        dice[0], dice[1], dice[2], dice[3], dice[4], dice[5] = c, b, f, a, e, d

    elif dir == 3: #북
        dice[0], dice[1], dice[2], dice[3], dice[4], dice[5] = e, a, c, d, f, b

    else:
        dice[0], dice[1], dice[2], dice[3], dice[4], dice[5] = b, f, c, d, a, e

dx, dy = [0,0,-1,1], [1,-1,0,0]

for i in kli: # 원소 그대로 방향 하는 느낌쓰~
  x = x +dx[i-1]
  y = y +dy[i-1]

  if 0<=x<n and 0<=y<m:
    turn(i)

    if g[x][y] == 0:
        g[x][y] = dice[-1]
    else:
        dice[-1] = g[x][y]
        g[x][y] = 0

    print(dice[0])
    
  else:
    x = x - dx[i-1]
    y = y - dy[i-1] 
    
--------------------------------------------------------------------------------------------------------------
구슬 탈출 2
만약 기울린 후 파란 구슬의 위치가 구멍이 아니고, 파란 구슬과 빨간 구슬의 위치가 같으면 move 함수를 통해 
리턴받은 한 방향으로 움직인 횟수를 비교해서 만약 빨간 구슬이 더 움직였다면 파란 구슬 뒤로 이동하고,
 파란 구슬이 더 움직였다면 빨간 구슬 뒤로 이동시켜줌.

# BFS + 구현
from collections import deque

n, m = map(int, input().split())
graph = []
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
rx, ry, bx, by = 0, 0, 0, 0
# 빨간구슬과 파란구슬의 기울여서 이동한 위치를 visited 4차원 리스트를 통해 방문처리
visited = [[[[False] * m for _ in range(n)] for _ in range(m)] for _ in range(n)]

# 빨간, 파란 좌표처리
for i in range(n):
    data = list(input())
    graph.append(data)
    for d in range(len(data)):
        if data[d] == 'R':
            rx, ry = i, d
        elif data[d] == 'B':
            bx, by = i, d 

# 끝이 도착했으면 이동횟수 증가
def move(x, y, dx, dy):
    count = 0
    while graph[x+dx][y+dy] != '#' and graph[x][y] != 'O': 
        x += dx
        y += dy
        count += 1
    return x, y, count

def bfs(rx, ry, bx, by):
    q = deque()
    q.append((rx, ry, bx, by, 1))
    visited[rx][ry][bx][by] = True
    while q:
        r_x, r_y, b_x, b_y, depth = q.popleft()
        if depth > 10:
            break
        for i in range(4):
            r_nx, r_ny, r_cnt = move(r_x, r_y, dx[i], dy[i])
            b_nx, b_ny, b_cnt = move(b_x, b_y, dx[i], dy[i])
            if graph[b_nx][b_ny] != 'O':
                if graph[r_nx][r_ny] == 'O':
                    return depth
                if r_nx == b_nx and r_ny == b_ny:
                    if r_cnt > b_cnt:
                        r_nx -= dx[i]
                        r_ny -= dy[i]
                    else:
                        b_nx -= dx[i]
                        b_ny -= dy[i]
                if not visited[r_nx][r_ny][b_nx][b_ny]:
                    visited[r_nx][r_ny][b_nx][b_ny] = True
                    q.append((r_nx, r_ny, b_nx, b_ny, depth+1))
    return -1


print(bfs(rx, ry, bx, by))
